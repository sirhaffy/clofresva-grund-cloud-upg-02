name: Deploy Infrastructure and Application

on:
  push:
    branches: [ main ]
  workflow_dispatch:
    inputs:
      skip_ansible:
        description: 'Skip Ansible configuration'
        required: false
        default: 'false'

      full_deployment:
        description: 'Run full infrastructure deployment'
        required: false
        default: 'false'
env:
  PROJECT_NAME: ${{ secrets.PROJECT_NAME }}
  RESOURCE_GROUP: ${{ secrets.RESOURCE_GROUP }}
  LOCATION: northeurope
  REPO_NAME: ${{ secrets.REPO_NAME }}

jobs:



  # ===========================================================================================
  # =================================Check Changed Files=======================================
  # ===========================================================================================



  # Check for changes to determine what needs to be run.
  check-changes:
    name: Check Changed Files
    runs-on: ubuntu-latest
    outputs:
      run_bicep: ${{ steps.check_files.outputs.run_bicep }}
      run_ansible: ${{ steps.check_files.outputs.run_ansible }}
      run_webapp: ${{ steps.check_files.outputs.run_webapp }}
      changes_detected: ${{ steps.check_files.outputs.changes_detected }}
      change_summary: ${{ steps.check_files.outputs.change_summary }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 2

      - name: Check changed files
        id: check_files
        run: |
          # Check if this is a manual trigger (workflow_dispatch).
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            if [[ "${{ github.event.inputs.full_deployment }}" == "true" ]]; then
              echo "Manual workflow run - will execute all steps"
              echo "run_bicep=true" >> $GITHUB_OUTPUT
              echo "run_ansible=true" >> $GITHUB_OUTPUT
              echo "run_webapp=true" >> $GITHUB_OUTPUT
              echo "changes_detected=true" >> $GITHUB_OUTPUT
              echo "change_summary=Manual trigger: Running all deployment steps" >> $GITHUB_OUTPUT
              exit 0
            fi
          fi

          # For push/PR events, check what files changed.
          git diff --name-only HEAD^ HEAD > changed_files.txt

          # Debug - show what files are changed
          echo "List of changed files:"
          cat changed_files.txt

          # Initialize change flags.
          bicep_changes=false
          ansible_changes=false
          webapp_changes=false

          # Check for infrastructure changes.
          if grep -q "infrastructure/" changed_files.txt || \
            grep -q "bicep/" changed_files.txt || \
            grep -q "\.bicep$" changed_files.txt; then
            bicep_changes=true
          fi

          # Check for Ansible changes.
          if grep -q "ansible/" changed_files.txt || \
            grep -q "playbooks/" changed_files.txt || \
            grep -q "roles/" changed_files.txt || \
            grep -q "templates/" changed_files.txt || \
            grep -q "mongodb" changed_files.txt || \
            grep -q "cosmos" changed_files.txt; then
            ansible_changes=true
          fi

          # Check for webapp changes and show what we find
          echo "Checking for webapp related changes..."

          # Check for specific webapp files and show what we find
          if grep -i "\.cs" changed_files.txt; then
            echo "Found .cs file changes"
            webapp_changes=true
          fi

          if grep -i "\.csproj" changed_files.txt; then
            echo "Found .csproj file changes"
            webapp_changes=true
          fi

          if grep -i "WebbApp" changed_files.txt; then
            echo "Found WebbApp directory changes"
            webapp_changes=true
          fi

          if grep -i "wwwroot" changed_files.txt; then
            echo "Found wwwroot directory changes"
            webapp_changes=true
          fi

          if grep -i "Controllers" changed_files.txt; then
            echo "Found Controllers directory changes"
            webapp_changes=true
          fi

          if grep -i "Views" changed_files.txt; then
            echo "Found Views directory changes"
            webapp_changes=true
          fi

          if grep -i "Models" changed_files.txt; then
            echo "Found Models directory changes"
            webapp_changes=true
          fi

          # Print the final status
          echo "Final webapp_changes status: $webapp_changes"

          # Set outputs based on changes.
          echo "run_bicep=$bicep_changes" >> $GITHUB_OUTPUT
          echo "run_ansible=$ansible_changes" >> $GITHUB_OUTPUT
          echo "run_webapp=$webapp_changes" >> $GITHUB_OUTPUT

          # Determine if any changes were detected.
          changes_detected=$([ "$bicep_changes" = "true" ] || [ "$ansible_changes" = "true" ] || [ "$webapp_changes" = "true" ] && echo "true" || echo "false")
          echo "changes_detected=$changes_detected" >> $GITHUB_OUTPUT

          if [ "$bicep_changes" = "true" ] && (grep -q "mongodb" changed_files.txt || grep -q "cosmos" changed_files.txt); then
            ansible_changes=true
            echo "MongoDB/CosmosDB changes detected, will run Ansible"
          fi

          # Create a change summary.
          summary="Changes detected:\n"
          summary+="  Infrastructure: $bicep_changes\n"
          summary+="  Configuration: $ansible_changes\n"
          summary+="  Web Application: $webapp_changes\n"
          echo "change_summary=$summary" >> $GITHUB_OUTPUT

          # Echo the changes for the log
          echo "==================== CHANGE DETECTION SUMMARY ===================="
          echo -e "$summary"
          echo "================================================================="

          # List the changed files.
          cat changed_files.txt

      - name: Debug changes
        run: |
          echo "Files changed that caused infrastructure updates:"
          grep -E "infrastructure/|bicep/|\.bicep$" changed_files.txt || echo "No matching infrastructure files"

          echo "Files changed that caused ansible updates:"
          grep -E "ansible/|playbooks/|roles/|templates/|mongodb|cosmos" changed_files.txt || echo "No matching ansible files"

          echo "Files changed that caused webapp updates:"
          echo "  .cs files:"
          grep -i "\.cs" changed_files.txt | while read -r file; do
            echo "  - $file"
          done || echo "  No matching .cs files"

          echo "  .csproj files:"
          grep -i "\.csproj" changed_files.txt | while read -r file; do
            echo "  - $file"
          done || echo "  No matching .csproj files"

          echo "  WebbApp directory:"
          grep -i "WebbApp" changed_files.txt | while read -r file; do
            echo "  - $file"
          done || echo "  No matching WebbApp directory files"

          echo "  wwwroot directory:"
          grep -i "wwwroot" changed_files.txt | while read -r file; do
            echo "  - $file"
          done || echo "  No matching wwwroot directory files"

          echo "  Controllers directory:"
          grep -i "Controllers" changed_files.txt | while read -r file; do
            echo "  - $file"
          done || echo "  No matching Controllers directory files"

          echo "  Views directory:"
          grep -i "Views" changed_files.txt | while read -r file; do
            echo "  - $file"
          done || echo "  No matching Views directory files"

          echo "  Models directory:"
          grep -i "Models" changed_files.txt | while read -r file; do
            echo "  - $file"
          done || echo "  No matching Models directory files."




  # ===========================================================================================
  # =============================Get Existing Infrastructure Info==============================
  # ===========================================================================================



  # New job to get infrastructure info if we don't need to deploy infrastructure
  get-infrastructure-info:
    name: Get Existing Infrastructure Info

    needs: check-changes
    if: ${{ needs.check-changes.outputs.run_bicep == 'false' && (needs.check-changes.outputs.run_ansible == 'true' || needs.check-changes.outputs.run_webapp == 'true') }}

    runs-on: ubuntu-latest
    outputs:
      BASTION_IP: ${{ steps.get_infrastructure_data.outputs.BASTION_IP }}
      APP_IP: ${{ steps.get_infrastructure_data.outputs.APP_IP }}
      MONGODB_CONNECTION_STRING: ${{ steps.get_infrastructure_data.outputs.MONGODB_CONNECTION_STRING }}
      MONGODB_CONNECTION_STRING_B64: ${{ steps.get_infrastructure_data.outputs.MONGODB_CONNECTION_STRING_B64 }}
      STORAGE_ACCOUNT: ${{ steps.get_infrastructure_data.outputs.STORAGE_ACCOUNT }}
      BLOB_ENDPOINT: ${{ steps.get_infrastructure_data.outputs.BLOB_ENDPOINT }}
      RUNNER_TOKEN: ${{ steps.generate_token.outputs.RUNNER_TOKEN }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Azure Login
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      # Use our reusable SSH setup
      - name: Set up SSH keys
        uses: ./.github/actions/setup-ssh
        with:
          ssh_private_key: ${{ secrets.SSH_PRIVATE_KEY }}

      # Generate a new runner token
      - name: Generate runner token
        id: generate_token
        run: |
          TOKEN=$(curl -X POST -H "Authorization: token ${{ secrets.PAT_TOKEN }}" \
            -H "Accept: application/vnd.github+json" \
            https://api.github.com/repos/${{ env.REPO_NAME }}/actions/runners/registration-token \
            | jq -r .token)

          # Set the token as environment variable and output.
          echo "RUNNER_TOKEN=$TOKEN" >> $GITHUB_ENV
          echo "RUNNER_TOKEN=$TOKEN" >> $GITHUB_OUTPUT
          echo "::add-mask::$TOKEN"

          # Check if the token is available.
          echo "Debug: Runner token"
          echo "PAT token available: ${{ secrets.PAT_TOKEN != '' }}"
          echo "Runner token available: $([[ -n "$TOKEN" ]] && echo "Yes" || echo "No")"
          echo "REPO_NAME: ${{ env.REPO_NAME }}"

      # Get the infrastructure info from Azure
      - name: Get Infrastructure Data
        id: get_infrastructure_data
        run: |
          echo "Getting Bastion IP..."
          BASTION_IP=$(az deployment group show \
            --resource-group ${{ env.RESOURCE_GROUP }} \
            --name main \
            --query "properties.outputs.bastionHostIp.value" \
            --output tsv 2>/dev/null) || BASTION_IP=""

          if [ -z "$BASTION_IP" ]; then
            # Try to find the bastion VM/IP directly if deployment output is not available
            BASTION_IP=$(az vm list-ip-addresses \
              --resource-group ${{ env.RESOURCE_GROUP }} \
              --name "${{ env.PROJECT_NAME }}-bastion-vm" \
              --query "[0].virtualMachine.network.publicIpAddresses[0].ipAddress" \
              --output tsv 2>/dev/null) || BASTION_IP=""
          fi

          echo "Getting App server IP..."
          APP_IP=$(az deployment group show \
            --resource-group ${{ env.RESOURCE_GROUP }} \
            --name main \
            --query "properties.outputs.appServerPrivateIp.value" \
            --output tsv 2>/dev/null) || APP_IP=""

          if [ -z "$APP_IP" ]; then
            # Try to find the app VM/IP directly
            APP_IP=$(az vm list-ip-addresses \
              --resource-group ${{ env.RESOURCE_GROUP }} \
              --name "${{ env.PROJECT_NAME }}-app-vm" \
              --query "[0].virtualMachine.network.privateIpAddresses[0]" \
              --output tsv 2>/dev/null) || APP_IP=""
          fi

          echo "Getting MongoDB connection string..."
          MONGODB_CONNECTION_STRING=$(az deployment group show \
            --resource-group ${{ env.RESOURCE_GROUP }} \
            --name main \
            --query "properties.outputs.mongoDbConnectionString.value" \
            --output tsv 2>/dev/null) || MONGODB_CONNECTION_STRING=""

          echo "Getting storage account name..."
          STORAGE_ACCOUNT=$(az deployment group show \
            --resource-group ${{ env.RESOURCE_GROUP }} \
            --name main \
            --query "properties.outputs.storageAccountName.value" \
            --output tsv 2>/dev/null) || STORAGE_ACCOUNT=""

          if [ -z "$STORAGE_ACCOUNT" ]; then
            # Try to find storage account directly
            STORAGE_ACCOUNT=$(az storage account list \
              --resource-group ${{ env.RESOURCE_GROUP }} \
              --query "[?starts_with(name, '${{ env.PROJECT_NAME }}')].name" \
              --output tsv 2>/dev/null | head -1) || STORAGE_ACCOUNT=""
          fi

          echo "Getting blob endpoint..."
          if [ -n "$STORAGE_ACCOUNT" ]; then
            BLOB_ENDPOINT=$(az storage account show \
              --resource-group ${{ env.RESOURCE_GROUP }} \
              --name $STORAGE_ACCOUNT \
              --query "primaryEndpoints.blob" \
              --output tsv 2>/dev/null) || BLOB_ENDPOINT=""
          else
            BLOB_ENDPOINT=""
          fi

          # Check and display what we found
          echo "Found resources:"
          echo "Bastion IP: $BASTION_IP"
          echo "App IP: $APP_IP"
          echo "Storage Account: $STORAGE_ACCOUNT"
          echo "Blob Endpoint: $BLOB_ENDPOINT"
          echo "MongoDB connection string found: $([ -n "$MONGODB_CONNECTION_STRING" ] && echo "Yes" || echo "No")"

          # Set the outputs for subsequent jobs
          echo "BASTION_IP=$BASTION_IP" >> $GITHUB_OUTPUT
          echo "APP_IP=$APP_IP" >> $GITHUB_OUTPUT
          echo "MONGODB_CONNECTION_STRING=$MONGODB_CONNECTION_STRING" >> $GITHUB_OUTPUT
          echo "STORAGE_ACCOUNT=$STORAGE_ACCOUNT" >> $GITHUB_OUTPUT
          echo "BLOB_ENDPOINT=$BLOB_ENDPOINT" >> $GITHUB_OUTPUT

          # Base64 encode MongoDB connection string if it exists
          if [ -n "$MONGODB_CONNECTION_STRING" ] && [ ${#MONGODB_CONNECTION_STRING} -gt 20 ]; then
            MONGODB_CONNECTION_STRING_B64=$(echo -n "$MONGODB_CONNECTION_STRING" | base64 -w0)
            echo "MONGODB_CONNECTION_STRING_B64=$MONGODB_CONNECTION_STRING_B64" >> $GITHUB_OUTPUT
            echo "Encoded MongoDB connection string (first 10 chars): ${MONGODB_CONNECTION_STRING_B64:0:10}..."
          else
            echo "Warning: MongoDB connection string not found or too short"
          fi








  # ===========================================================================================
  # ==============================Deploy Azure Infrastructure==================================
  # ===========================================================================================



  # Check if dotnet app files were changed.
  deploy-infrastructure:
    name: Deploy Azure Infrastructure
    needs: check-changes
    if: ${{ needs.check-changes.outputs.run_bicep == 'true' }}
    runs-on: ubuntu-latest
    outputs:
      BASTION_IP: ${{ steps.deployment_data.outputs.BASTION_IP }}
      APP_IP: ${{ steps.deployment_data.outputs.APP_IP }}
      MONGODB_CONNECTION_STRING: ${{ steps.deployment_data.outputs.MONGODB_CONNECTION_STRING }}
      MONGODB_CONNECTION_STRING_B64: ${{ steps.deployment_data.outputs.MONGODB_CONNECTION_STRING_B64 }}
      STORAGE_ACCOUNT: ${{ steps.deployment_data.outputs.STORAGE_ACCOUNT }}
      BLOB_ENDPOINT: ${{ steps.deployment_data.outputs.BLOB_ENDPOINT }}
      RUNNER_TOKEN: ${{ steps.generate_token.outputs.RUNNER_TOKEN }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Azure Login
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      # Use our reusable SSH setup
      - name: Set up SSH keys
        uses: ./.github/actions/setup-ssh
        with:
          ssh_private_key: ${{ secrets.SSH_PRIVATE_KEY }}

      # Generate a new runner token
      - name: Generate runner token
        id: generate_token
        run: |
          TOKEN=$(curl -X POST -H "Authorization: token ${{ secrets.PAT_TOKEN }}" \
            -H "Accept: application/vnd.github+json" \
            https://api.github.com/repos/${{ env.REPO_NAME }}/actions/runners/registration-token \
            | jq -r .token)

          # Set the token as environment variable and output.
          echo "RUNNER_TOKEN=$TOKEN" >> $GITHUB_ENV
          echo "RUNNER_TOKEN=$TOKEN" >> $GITHUB_OUTPUT
          echo "::add-mask::$TOKEN"

          # Check if the token is available.
          echo "Debug: Runner token"
          echo "PAT token available: ${{ secrets.PAT_TOKEN != '' }}"
          echo "Runner token available: $([[ -n "$TOKEN" ]] && echo "Yes" || echo "No")"
          echo "REPO_NAME: ${{ env.REPO_NAME }}"

      # Deploy the infrastructure using Bicep
      - name: Deploy Infrastructure
        id: deploy
        uses: azure/arm-deploy@v1
        with:
          scope: resourcegroup
          resourceGroupName: ${{ env.RESOURCE_GROUP }}
          template: ./infrastructure/bicep/main.bicep
          parameters: >
            projectName=${{ env.PROJECT_NAME }}
            adminUsername=azureuser
            sshPublicKey="${{ secrets.SSH_PUBLIC_KEY }}"
            location=${{ env.LOCATION }}
          deploymentName: main

      # Get the outputs from the deployment
      - name: Get Deployment Outputs
        id: deployment_data
        run: |

          echo "Getting Bastion IP..."
          BASTION_IP=$(az deployment group show \
            --resource-group ${{ env.RESOURCE_GROUP }} \
            --name main \
            --query "properties.outputs.bastionHostIp.value" \
            --output tsv)

          # Check if the bastion IP is available
          echo "Bastion IP available: $([[ -n "$BASTION_IP" ]] && echo "Yes" || echo "No")"

          # Debug: Print the Bastion IP
          echo "Bastion IP: $BASTION_IP"

          echo "Getting App server IP..."
          APP_IP=$(az deployment group show \
            --resource-group ${{ env.RESOURCE_GROUP }} \
            --name main \
            --query "properties.outputs.appServerPrivateIp.value" \
            --output tsv)

          # Check if the app IP is available
          echo "App IP available: $([[ -n "$APP_IP" ]] && echo "Yes" || echo "No")"

          # Debug: Print the App IP
          echo "App IP: $APP_IP"

          echo "Getting MongoDB connection string..."
          MONGODB_CONNECTION_STRING=$(az deployment group show \
            --resource-group ${{ env.RESOURCE_GROUP }} \
            --name main \
            --query "properties.outputs.mongoDbConnectionString.value" \
            --output tsv)

          # debug: Print the MongoDB connection string
          echo "Available outputs:"
            az deployment group show \
              --resource-group ${{ env.RESOURCE_GROUP }} \
              --name main \
              --query "properties.outputs" \
              --output json

          # Check if the connection string is available
          echo "Connection string available: $([[ -n "$MONGODB_CONNECTION_STRING" ]] && echo "Yes" || echo "No")"

          # Debug: Print the MongoDB connection string
          echo "MongoDB connection string: $MONGODB_CONNECTION_STRING"

          echo "Getting storage account name..."
          STORAGE_ACCOUNT=$(az deployment group show \
            --resource-group ${{ env.RESOURCE_GROUP }} \
            --name main \
            --query "properties.outputs.storageAccountName.value" \
            --output tsv)

          # Check if the storage account is available
          echo "Storage account available: $([[ -n "$STORAGE_ACCOUNT" ]] && echo "Yes" || echo "No")"

          # Debug: Print the storage account name
          echo "Storage account: $STORAGE_ACCOUNT"

          echo "Getting blob endpoint..."
          BLOB_ENDPOINT=$(az deployment group show \
            --resource-group ${{ env.RESOURCE_GROUP }} \
            --name main \
            --query "properties.outputs.blobEndpoint.value" \
            --output tsv)

          # Check if the blob endpoint is available
          echo "Blob endpoint available: $([[ -n "$BLOB_ENDPOINT" ]] && echo "Yes" || echo "No")"

          # Debug: Print the Blob endpoint
          echo "Blob endpoint: $BLOB_ENDPOINT"

          # Output the values to the console.
          # echo "Bastion IP: $BASTION_IP"
          # echo "App IP: $APP_IP"
          # echo "Storage Account: $STORAGE_ACCOUNT"
          # echo "Blob Endpoint: $BLOB_ENDPOINT"
          # echo "MongoDB connection string length: ${#MONGODB_CONNECTION_STRING}"

          # Set the environment variables.
          echo "BASTION_IP=$BASTION_IP" >> $GITHUB_ENV
          echo "APP_IP=$APP_IP" >> $GITHUB_ENV
          echo "MONGODB_CONNECTION_STRING=$MONGODB_CONNECTION_STRING" >> $GITHUB_ENV
          echo "STORAGE_ACCOUNT=$STORAGE_ACCOUNT" >> $GITHUB_ENV
          echo "BLOB_ENDPOINT=$BLOB_ENDPOINT" >> $GITHUB_ENV

          # Set the outputs for subsequent jobs.
          echo "BASTION_IP=$BASTION_IP" >> $GITHUB_OUTPUT
          echo "APP_IP=$APP_IP" >> $GITHUB_OUTPUT
          echo "MONGODB_CONNECTION_STRING=$MONGODB_CONNECTION_STRING" >> $GITHUB_OUTPUT
          echo "STORAGE_ACCOUNT=$STORAGE_ACCOUNT" >> $GITHUB_OUTPUT
          echo "BLOB_ENDPOINT=$BLOB_ENDPOINT" >> $GITHUB_OUTPUT

          # Base64 encode MongoDB connection string
          if [ -n "$MONGODB_CONNECTION_STRING" ] && [ ${#MONGODB_CONNECTION_STRING} -gt 20 ]; then
            MONGODB_CONNECTION_STRING_B64=$(echo -n "$MONGODB_CONNECTION_STRING" | base64 -w0)
            echo "MONGODB_CONNECTION_STRING_B64=$MONGODB_CONNECTION_STRING_B64" >> $GITHUB_ENV
            echo "MONGODB_CONNECTION_STRING_B64=$MONGODB_CONNECTION_STRING_B64" >> $GITHUB_OUTPUT
            echo "Encoded MongoDB connection string (first 10 chars): ${MONGODB_CONNECTION_STRING_B64:0:10}..."
          else
            echo "Warning: Invalid MongoDB connection string, length: ${#MONGODB_CONNECTION_STRING}"
          fi

      - name: Ensure Ansible config exists
        run: |
          mkdir -p ./ansible
          echo "[defaults]" > ./ansible/ansible.cfg
          echo "host_key_checking = False" >> ./ansible/ansible.cfg
          echo "roles_path = ./ansible/roles" >> ./ansible/ansible.cfg

          # Set the environment variable
          echo "ANSIBLE_CONFIG=./ansible/ansible.cfg" >> $GITHUB_ENV

          # Debug directory structure
          echo "Directory structure:"
          find ./ansible -type d | sort

      - name: Test SSH connectivity
        run: |
          # Check if environment variables are available
          if [ -z "${{ env.APP_IP }}" ] || [ -z "${{ env.BASTION_IP }}" ]; then
            echo "WARNING: IP addresses not set. Using hardcoded values."
            APP_IP="10.0.2.4"
            BASTION_IP="137.116.232.168"
          else
            APP_IP="${{ env.APP_IP }}"
            BASTION_IP="${{ env.BASTION_IP }}"
          fi

          # Test SSH to bastion
          echo "Testing SSH to bastion host at $BASTION_IP..."
          ssh -i ~/.ssh/clofresva_gc_upg02_azure_key -o ConnectTimeout=10 azureuser@$BASTION_IP "echo 'Bastion connection successful!'" || echo "WARNING: Bastion connection failed!"

          # Test SSH to app server via bastion
          echo "Testing SSH to app server at $APP_IP via bastion..."
          ssh -i ~/.ssh/clofresva_gc_upg02_azure_key -o ConnectTimeout=10 -o ProxyCommand="ssh -W %h:%p -i ~/.ssh/clofresva_gc_upg02_azure_key azureuser@$BASTION_IP" azureuser@$APP_IP "echo 'App server connection successful!'" || echo "WARNING: App server connection failed!"



  # ===========================================================================================
  # ==============================Configure Servers with Ansible===============================
  # ===========================================================================================



  configure-servers:
    name: Configure Servers with Ansible
    needs: [check-changes, deploy-infrastructure, get-infrastructure-info]
    if: >
      ${{ always() &&
      needs.check-changes.outputs.run_ansible == 'true' &&
      (needs.deploy-infrastructure.result == 'success' ||
      (needs.deploy-infrastructure.result == 'skipped' && needs.get-infrastructure-info.result == 'success')) }}
    runs-on: ubuntu-latest
    env:
      BASTION_IP: ${{ needs.deploy-infrastructure.outputs.BASTION_IP != '' && needs.deploy-infrastructure.outputs.BASTION_IP || needs.get-infrastructure-info.outputs.BASTION_IP }}
      APP_IP: ${{ needs.deploy-infrastructure.outputs.APP_IP != '' && needs.deploy-infrastructure.outputs.APP_IP || needs.get-infrastructure-info.outputs.APP_IP }}
      MONGODB_CONNECTION_STRING: ${{ needs.deploy-infrastructure.outputs.MONGODB_CONNECTION_STRING != '' && needs.deploy-infrastructure.outputs.MONGODB_CONNECTION_STRING || needs.get-infrastructure-info.outputs.MONGODB_CONNECTION_STRING }}
      MONGODB_CONNECTION_STRING_B64: ${{ needs.deploy-infrastructure.outputs.MONGODB_CONNECTION_STRING_B64 != '' && needs.deploy-infrastructure.outputs.MONGODB_CONNECTION_STRING_B64 || needs.get-infrastructure-info.outputs.MONGODB_CONNECTION_STRING_B64 }}
      STORAGE_ACCOUNT: ${{ needs.deploy-infrastructure.outputs.STORAGE_ACCOUNT != '' && needs.deploy-infrastructure.outputs.STORAGE_ACCOUNT || needs.get-infrastructure-info.outputs.STORAGE_ACCOUNT }}
      BLOB_ENDPOINT: ${{ needs.deploy-infrastructure.outputs.BLOB_ENDPOINT != '' && needs.deploy-infrastructure.outputs.BLOB_ENDPOINT || needs.get-infrastructure-info.outputs.BLOB_ENDPOINT }}
      RUNNER_TOKEN: ${{ needs.deploy-infrastructure.outputs.RUNNER_TOKEN != '' && needs.deploy-infrastructure.outputs.RUNNER_TOKEN || needs.get-infrastructure-info.outputs.RUNNER_TOKEN }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      # Använd vår återanvändbara SSH-uppsättning
      - name: Set up SSH keys
        uses: ./.github/actions/setup-ssh
        with:
          ssh_private_key: ${{ secrets.SSH_PRIVATE_KEY }}

      - name: Debug environment variables
        run: |
          echo "Environment variables:"
          echo "BASTION_IP: ${{ env.BASTION_IP }}"
          echo "APP_IP: ${{ env.APP_IP }}"
          echo "PROJECT_NAME: ${{ env.PROJECT_NAME }}"
          echo "STORAGE_ACCOUNT: ${{ env.STORAGE_ACCOUNT }}"
          echo "BLOB_ENDPOINT: ${{ env.BLOB_ENDPOINT }}"
          echo "REPO_NAME: ${{ env.REPO_NAME }}"
          echo "RUNNER_TOKEN available: ${{ env.RUNNER_TOKEN != '' }}"
          echo "RUNNER_TOKEN length: ${#RUNNER_TOKEN}"

          echo "RUNNER_TOKEN from output: ${{ needs.deploy-infrastructure.outputs.RUNNER_TOKEN != '' }}"
          echo "RUNNER_TOKEN from env: $([[ -n \"$RUNNER_TOKEN\" ]] && echo 'Yes' || echo 'No')"

      - name: Ensure Ansible config exists
        run: |
          mkdir -p ./ansible
          echo "[defaults]" > ./ansible/ansible.cfg
          echo "host_key_checking = False" >> ./ansible/ansible.cfg
          echo "roles_path = ./ansible/roles" >> ./ansible/ansible.cfg

          # Set the environment variable
          echo "ANSIBLE_CONFIG=./ansible/ansible.cfg" >> $GITHUB_ENV

          # Debug directory structure
          echo "Directory structure:"
          find ./ansible -type d | sort

      - name: Test SSH connectivity
        run: |
          # Check if environment variables are available
          if [ -z "${{ env.APP_IP }}" ] || [ -z "${{ env.BASTION_IP }}" ]; then
            echo "WARNING: IP addresses not set. Using hardcoded values."
            APP_IP="10.0.2.4"
            BASTION_IP="137.116.232.168"
          else
            APP_IP="${{ env.APP_IP }}"
            BASTION_IP="${{ env.BASTION_IP }}"
          fi

          # Test SSH to bastion
          echo "Testing SSH to bastion host at $BASTION_IP..."
          ssh -i ~/.ssh/clofresva_gc_upg02_azure_key -o ConnectTimeout=10 azureuser@$BASTION_IP "echo 'Bastion connection successful!'" || echo "WARNING: Bastion connection failed!"

          # Test SSH to app server via bastion
          echo "Testing SSH to app server at $APP_IP via bastion..."
          ssh -i ~/.ssh/clofresva_gc_upg02_azure_key -o ConnectTimeout=10 -o ProxyCommand="ssh -W %h:%p -i ~/.ssh/clofresva_gc_upg02_azure_key azureuser@$BASTION_IP" azureuser@$APP_IP "echo 'App server connection successful!'" || echo "WARNING: App server connection failed!"

      # Run Ansible to configure servers
      - name: Run Ansible
        run: |
          # Create ansible inventory directory
          mkdir -p ./ansible/inventories

          # Check if environment variables are available
          if [ -z "${{ env.APP_IP }}" ] || [ -z "${{ env.BASTION_IP }}" ]; then
            echo "WARNING: IP addresses not set. Using hardcoded values."
            APP_IP="10.0.2.4"
            BASTION_IP="137.116.232.168"
          else
            APP_IP="${{ env.APP_IP }}"
            BASTION_IP="${{ env.BASTION_IP }}"
          fi

          echo "Using App IP: $APP_IP"
          echo "Using Bastion IP: $BASTION_IP"

          # Create inventory file
          echo "all:" > ./ansible/inventories/azure_rm.yaml
          echo "  hosts:" >> ./ansible/inventories/azure_rm.yaml
          echo "    app_server:" >> ./ansible/inventories/azure_rm.yaml
          echo "      ansible_host: $APP_IP" >> ./ansible/inventories/azure_rm.yaml
          echo "      ansible_user: azureuser" >> ./ansible/inventories/azure_rm.yaml
          echo "      ansible_ssh_private_key_file: ~/.ssh/clofresva_gc_upg02_azure_key" >> ./ansible/inventories/azure_rm.yaml
          echo "      ansible_ssh_common_args: '-o ProxyCommand=\"ssh -W %h:%p -i ~/.ssh/clofresva_gc_upg02_azure_key azureuser@$BASTION_IP\"'" >> ./ansible/inventories/azure_rm.yaml
          echo "  vars:" >> ./ansible/inventories/azure_rm.yaml
          echo "    project_name: ${{ env.PROJECT_NAME }}" >> ./ansible/inventories/azure_rm.yaml
          echo "    storage_account: ${{ env.STORAGE_ACCOUNT }}" >> ./ansible/inventories/azure_rm.yaml
          echo "    blob_endpoint: ${{ env.BLOB_ENDPOINT }}" >> ./ansible/inventories/azure_rm.yaml
          echo "    container_name: appdata" >> ./ansible/inventories/azure_rm.yaml
          echo "    github_repo: ${{ env.REPO_NAME }}" >> ./ansible/inventories/azure_rm.yaml
          echo "    github_runner_token: ***" >> ./ansible/inventories/azure_rm.yaml
          # Säkert sätt att lägga till token i filen
          sed -i "s/github_runner_token: \*\*\*/github_runner_token: ${{ env.RUNNER_TOKEN }}/" ./ansible/inventories/azure_rm.yaml

          # Använd base64 för att undvika problem med specialtecken
          echo "    mongodb_connection_string_base64: ${{ env.MONGODB_CONNECTION_STRING_B64 }}" >> ./ansible/inventories/azure_rm.yaml

          # Debug - visa inventory med maskerat token
          echo "Generated inventory file (sensitive data masked):"
          cat ./ansible/inventories/azure_rm.yaml | sed 's/github_runner_token: .*/github_runner_token: ***/' | sed 's/mongodb_connection_string_base64: .*/mongodb_connection_string_base64: ***/'

          echo "Waiting for SSH to be available..."
          sleep 30

          # Kör Ansible en gång med error-hantering
          echo "Running Ansible with error handling..."
          if ! ansible-playbook -i ./ansible/inventories/azure_rm.yaml ./ansible/playbooks/app-server.yaml; then
            echo "::warning::Ansible playbook failed but workflow will continue"
            echo "ansible_failed=true" >> $GITHUB_ENV
          else
            echo "ansible_failed=false" >> $GITHUB_ENV
          fi
        continue-on-error: true # Continue even if Ansible fails



  # ===========================================================================================
  # =============================Deploy Application as Artifact===============================
  # ===========================================================================================



  # Build and deploy the dotnet app as an artifact and upload, if files were changed.
  deploy-app:
    name: Deploy Application as Artifact
    needs: [check-changes, deploy-infrastructure, get-infrastructure-info, configure-servers]
    if: >
      ${{ always() &&
      needs.check-changes.outputs.run_webapp == 'true' &&
      (needs.deploy-infrastructure.result == 'success' ||
      (needs.deploy-infrastructure.result == 'skipped' && needs.get-infrastructure-info.result == 'success')) }}
    runs-on: ubuntu-latest
    env:
      BASTION_IP: ${{ needs.deploy-infrastructure.outputs.BASTION_IP != '' && needs.deploy-infrastructure.outputs.BASTION_IP || needs.get-infrastructure-info.outputs.BASTION_IP }}
      APP_IP: ${{ needs.deploy-infrastructure.outputs.APP_IP != '' && needs.deploy-infrastructure.outputs.APP_IP || needs.get-infrastructure-info.outputs.APP_IP }}

    steps:
      # Check out the code from the repository
      - name: Checkout code
        uses: actions/checkout@v4

      # Använd vår återanvändbara SSH-uppsättning
      - name: Set up SSH keys
        uses: ./.github/actions/setup-ssh
        with:
          ssh_private_key: ${{ secrets.SSH_PRIVATE_KEY }}

      # Set up .NET SDK
      - name: Setup .NET
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: 9.0.x

      # Build the web application
      - name: Build Web App
        run: |
          # Backup existing app if it exists (via SSH) if setup failed.
          if [ "${{ env.APP_IP }}" != "" ] && [ "${{ env.BASTION_IP }}" != "" ]; then
            echo "Creating backup of existing app..."
            ssh -o ConnectTimeout=10 -o ProxyCommand="ssh -W %h:%p -i ~/.ssh/clofresva_gc_upg02_azure_key azureuser@$BASTION_IP" -i ~/.ssh/clofresva_gc_upg02_azure_key azureuser@$APP_IP "
              if [ -d /var/www/app ]; then
                sudo cp -r /var/www/app /var/www/app_backup_$(date +%Y%m%d_%H%M%S)
              fi
            " || echo "Could not create backup, continuing anyway"
          fi

          # Build app as normal
          dotnet publish ./WebbApp/MVC_TestApp.csproj -c Release -o ./publish

          # Verify published files
          echo "Listing published files:"
          ls -la ./publish/

          # Controll that the .dll file exists
          if [ -f "./publish/MVC_TestApp.dll" ]; then
            echo "MVC_TestApp.dll found!"
          else
            echo "WARNING: MVC_TestApp.dll NOT found!"
            echo "Files in directory:"
            find ./publish -name "*.dll"
          fi

      # Add a timestamp to the deployment for use in the app.
      - name: Add deploy timestamp
        run: |
          # Säkerställ att wwwroot-katalogen finns
          mkdir -p ./publish/wwwroot
          echo "$(date -u +"%Y-%m-%d %H:%M:%S")" > ./publish/wwwroot/deploy-timestamp.txt

      # Deploy the application to the server
      - name: Verify deployment
        run: |
          # Check if environment variables are available
          if [ -z "${{ env.APP_IP }}" ] || [ -z "${{ env.BASTION_IP }}" ]; then
            echo "WARNING: IP addresses not set. Using hardcoded values."
            APP_IP="10.0.2.4"
            BASTION_IP="137.116.232.168"
          else
            APP_IP="${{ env.APP_IP }}"
            BASTION_IP="${{ env.BASTION_IP }}"
          fi

          echo "Verifying deployment..."
          # Wait 10 seconds for the service to stabilize
          sleep 10

          # Check service status
          ssh -o ConnectTimeout=10 -o ProxyCommand="ssh -W %h:%p -i ~/.ssh/clofresva_gc_upg02_azure_key azureuser@$BASTION_IP" -i ~/.ssh/clofresva_gc_upg02_azure_key azureuser@$APP_IP "
            echo 'Service status:'
            sudo systemctl status webapp.service || true

            echo 'Running processes:'
            ps aux | grep dotnet

            echo 'Service logs:'
            sudo journalctl -u webapp.service --no-pager -n 20 || true
          "

      # Upload the artifact to the server
      - name: Upload App Artifact
        uses: actions/upload-artifact@v4
        with:
          name: webapp
          path: ./publish
          retention-days: 1



  # ===========================================================================================
  # ==============================Deploy Artifact to App-Server================================
  # ===========================================================================================



  # Deploy the artifact to the app server.
  deploy-to-server:
    name: Deploy Artifact to App-Server
    needs: [deploy-app, deploy-infrastructure, get-infrastructure-info]
    if: ${{ needs.deploy-app.result == 'success' && (needs.deploy-infrastructure.result == 'success' || (needs.deploy-infrastructure.result == 'skipped' && needs.get-infrastructure-info.result == 'success')) }}
    runs-on: ubuntu-latest
    env:
      BASTION_IP: ${{ needs.deploy-infrastructure.outputs.BASTION_IP != '' && needs.deploy-infrastructure.outputs.BASTION_IP || needs.get-infrastructure-info.outputs.BASTION_IP }}
      APP_IP: ${{ needs.deploy-infrastructure.outputs.APP_IP != '' && needs.deploy-infrastructure.outputs.APP_IP || needs.get-infrastructure-info.outputs.APP_IP }}
      MONGODB_CONNECTION_STRING: ${{ needs.deploy-infrastructure.outputs.MONGODB_CONNECTION_STRING != '' && needs.deploy-infrastructure.outputs.MONGODB_CONNECTION_STRING || needs.get-infrastructure-info.outputs.MONGODB_CONNECTION_STRING }}
      MONGODB_CONNECTION_STRING_B64: ${{ needs.deploy-infrastructure.outputs.MONGODB_CONNECTION_STRING_B64 != '' && needs.deploy-infrastructure.outputs.MONGODB_CONNECTION_STRING_B64 || needs.get-infrastructure-info.outputs.MONGODB_CONNECTION_STRING_B64 }}
      STORAGE_ACCOUNT: ${{ needs.deploy-infrastructure.outputs.STORAGE_ACCOUNT != '' && needs.deploy-infrastructure.outputs.STORAGE_ACCOUNT || needs.get-infrastructure-info.outputs.STORAGE_ACCOUNT }}
      BLOB_ENDPOINT: ${{ needs.deploy-infrastructure.outputs.BLOB_ENDPOINT != '' && needs.deploy-infrastructure.outputs.BLOB_ENDPOINT || needs.get-infrastructure-info.outputs.BLOB_ENDPOINT }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      # - name: Set IP variables
      #   run: |
      #     # Check if environment variables are available and set effective values if not.
      #     if [ -z "${{ env.APP_IP }}" ] || [ -z "${{ env.BASTION_IP }}" ]; then
      #       echo "Using fallback IP addresses"
      #       echo "EFFECTIVE_APP_IP=10.0.2.4" >> $GITHUB_ENV
      #       echo "EFFECTIVE_BASTION_IP=137.116.232.168" >> $GITHUB_ENV
      #     else
      #       echo "Using outputs from infrastructure deployment"
      #       echo "EFFECTIVE_APP_IP=${{ env.APP_IP }}" >> $GITHUB_ENV
      #       echo "EFFECTIVE_BASTION_IP=${{ env.BASTION_IP }}" >> $GITHUB_ENV
      #     fi

      # Use the SSH setup action.
      - name: Set up SSH keys
        uses: ./.github/actions/setup-ssh
        with:
          ssh_private_key: ${{ secrets.SSH_PRIVATE_KEY }}

      - name: Debug SSH configuration
        run: |
          echo "SSH directory contents:"
          ls -la ~/.ssh/

          echo "SSH config file:"
          cat ~/.ssh/config

          # Check if environment variables are available
          if [ -z "${{ env.APP_IP }}" ] || [ -z "${{ env.BASTION_IP }}" ]; then
            echo "WARNING: IP addresses not set. Using hardcoded values."
            APP_IP="10.0.2.4"
            BASTION_IP="137.116.232.168"
          else
            APP_IP="${{ env.APP_IP }}"
            BASTION_IP="${{ env.BASTION_IP }}"
          fi

          echo "Testing SSH connectivity:"
          echo "Bastion IP: $BASTION_IP"
          ssh -v -i ~/.ssh/clofresva_gc_upg02_azure_key \
            azureuser@$BASTION_IP \
            "echo 'Connected to Bastion'" || echo "Failed to connect to Bastion"

      - name: Download App Artifact
        uses: actions/download-artifact@v4
        with:
          name: webapp
          path: ./webapp-files

      - name: Remove appsettings.json before deployment
        run: |
          echo "Removing appsettings.json from artifact to prevent overriding server configuration..."
          rm -f ./webapp-files/appsettings.json
          echo "Files after removal:"
          ls -la ./webapp-files/

      - name: Create target directory and deploy app
        run: |
          echo "Creating webapp-files directory..."
          mkdir -p ./webapp-files

          # Check if environment variables are available
          if [ -z "${{ env.APP_IP }}" ] || [ -z "${{ env.BASTION_IP }}" ]; then
            echo "WARNING: IP addresses not set. Using hardcoded values."
            APP_IP="10.0.2.4"
            BASTION_IP="137.116.232.168"
          else
            APP_IP="${{ env.APP_IP }}"
            BASTION_IP="${{ env.BASTION_IP }}"
          fi

          echo "Using App IP: $APP_IP"
          echo "Using Bastion IP: $BASTION_IP"

          echo "Creating target directory on remote server..."
          ssh -o ConnectTimeout=10 -o ProxyCommand="ssh -W %h:%p -i ~/.ssh/clofresva_gc_upg02_azure_key azureuser@$BASTION_IP" -i ~/.ssh/clofresva_gc_upg02_azure_key azureuser@$APP_IP "sudo mkdir -p /tmp/webapp && sudo chown azureuser:azureuser /tmp/webapp"

          echo "Copying files to remote server..."
          scp -o ConnectTimeout=10 -o ProxyCommand="ssh -W %h:%p -i ~/.ssh/clofresva_gc_upg02_azure_key azureuser@$BASTION_IP" -i ~/.ssh/clofresva_gc_upg02_azure_key -r ./webapp-files/* azureuser@$APP_IP:/tmp/webapp/

          echo "Deploying files on app server..."
          ssh -o ConnectTimeout=10 -o ProxyCommand="ssh -W %h:%p -i ~/.ssh/clofresva_gc_upg02_azure_key azureuser@$BASTION_IP" -i ~/.ssh/clofresva_gc_upg02_azure_key azureuser@$APP_IP "
            echo 'Deploying application...'
            sudo systemctl stop webapp.service || echo 'Service not running yet'

            echo 'Removing old files...'
            sudo rm -rf /var/www/app/*
            sudo mkdir -p /var/www/app

            echo 'Copy files to webapp directory...'
            sudo cp -r /tmp/webapp/* /var/www/app/
            sudo chown -R www-data:www-data /var/www/app

            # Säkerhetskontroll: se till att appsettings.json finns, annars återställ från ansible mall
            if [ ! -f /var/www/app/appsettings.json ]; then
              echo 'appsettings.json missing, restoring from ansible template...'
              sudo ansible-playbook -i /etc/ansible/inventories/local.yaml /etc/ansible/playbooks/restore-config.yaml || true
            fi

            # Skapa wwwroot om det inte finns
            sudo mkdir -p /var/www/app/wwwroot
            sudo chown -R www-data:www-data /var/www/app/wwwroot

            echo 'Listing files in webapp directory...'
            ls -la /var/www/app/

            echo 'Restarting service...'
            sudo systemctl daemon-reload
            sudo systemctl restart webapp.service

            echo 'Service status:'
            sudo systemctl status webapp.service || true
            ps aux | grep dotnet

            echo 'Service logs:'
            sudo journalctl -u webapp.service --no-pager -n 50 || true

            echo 'Application deployed!'
          "

      - name: Verify server configuration
        run: |
          ssh -o ConnectTimeout=10 -o ProxyCommand="ssh -W %h:%p -i ~/.ssh/clofresva_gc_upg02_azure_key azureuser@$BASTION_IP" -i ~/.ssh/clofresva_gc_upg02_azure_key azureuser@$APP_IP "
            echo 'Verifying server configuration...'
            if grep -q '{accountname}' /var/www/app/appsettings.json; then
              echo 'WARNING: Default placeholder values detected in appsettings.json!'
              exit 1
            else
              echo 'Server configuration appears valid.'
            fi
          "