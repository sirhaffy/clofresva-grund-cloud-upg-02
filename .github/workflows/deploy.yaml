name: Deploy Infrastructure and Application

on:
  push:
    branches: [ main ]
  workflow_dispatch:
    inputs:
      skip_ansible:
        description: 'Skip Ansible configuration'
        required: false
        default: 'false'

      skip_bicep:
        description: 'Skip Bicep deployment'
        required: false
        default: 'false'

      run_webapp:
        description: 'Force run webapp deployment'
        required: false
        default: 'false'

      full_deployment:
        description: 'Run full infrastructure deployment'
        required: false
        default: 'false'

env:
  PROJECT_NAME: ${{ secrets.PROJECT_NAME }}
  RESOURCE_GROUP: ${{ secrets.RESOURCE_GROUP }}
  LOCATION: northeurope
  REPO_NAME: ${{ secrets.REPO_NAME }}


jobs:



  # ===========================================================================================
  # =================================Check Changed Files=======================================
  # ===========================================================================================



  # Check for changes to determine what needs to be run.
  check-changes:
    name: Check Changed Files
    runs-on: ubuntu-latest
    outputs:
      run_bicep: ${{ steps.check_files.outputs.run_bicep }}
      run_ansible: ${{ steps.check_files.outputs.run_ansible }}
      run_webapp: ${{ steps.check_files.outputs.run_webapp }}
      changes_detected: ${{ steps.check_files.outputs.changes_detected }}
      change_summary: ${{ steps.check_files.outputs.change_summary }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 2

      - name: Check changed files
        id: check_files
        run: |
          # Hantera manuella körningar först
          if [[ "${{ github.event_name }}" == "workflow_dispatch" && "${{ github.event.inputs.full_deployment }}" == "true" ]]; then
            echo "Manuell körning - kör alla steg"
            echo "run_bicep=true" >> $GITHUB_OUTPUT
            echo "run_ansible=true" >> $GITHUB_OUTPUT
            echo "run_webapp=true" >> $GITHUB_OUTPUT
            echo "changes_detected=true" >> $GITHUB_OUTPUT
            echo "change_summary=Manuell trigger: Kör alla deployment-steg" >> $GITHUB_OUTPUT
            exit 0
          fi

          # Hämta ändrade filer
          git diff --name-only HEAD^ HEAD > changed_files.txt
          echo "Ändrade filer:"
          cat changed_files.txt

          # Definiera mönster för olika ändringstyper
          BICEP_PATTERNS="infrastructure/ bicep/ \.bicep$"
          ANSIBLE_PATTERNS="ansible/ playbooks/ roles/ templates/ mongodb cosmos"
          WEBAPP_PATTERNS="\.cs$ \.cshtml$ \.csproj$ WebbApp/ wwwroot/ Controllers/ Views/ Models/"

          # Initiera flaggor till false
          bicep_changes=false
          ansible_changes=false
          webapp_changes=false

          # Kontrollera ändringar med en loop genom filerna
          while IFS= read -r file; do
            # För varje kategori, kolla om filen matchar något mönster
            for pattern in $BICEP_PATTERNS; do
              if [[ "$file" =~ $pattern ]]; then
                bicep_changes=true
                break
              fi
            done

            for pattern in $ANSIBLE_PATTERNS; do
              if [[ "$file" =~ $pattern ]]; then
                ansible_changes=true
                break
              fi
            done

            for pattern in $WEBAPP_PATTERNS; do
              if [[ "$file" =~ $pattern ]]; then
                webapp_changes=true
                break
              fi
            done
          done < changed_files.txt

          # echo "DEBUG: Checking webapp patterns matching..."
          # for pattern in $WEBAPP_PATTERNS; do
          #   echo "  Pattern: $pattern"
          #   grep -E "$pattern" changed_files.txt || echo "  No matches for this pattern"
          # done

          # Sätt outputs baserat på ändringar
          echo "run_bicep=$bicep_changes" >> $GITHUB_OUTPUT
          echo "run_ansible=$ansible_changes" >> $GITHUB_OUTPUT
          echo "run_webapp=$webapp_changes" >> $GITHUB_OUTPUT

          # Bestäm om några ändringar upptäcktes
          if [[ "$bicep_changes" == "true" || "$ansible_changes" == "true" || "$webapp_changes" == "true" ]]; then
            changes_detected=true
          else
            changes_detected=false
            # Ignorera om bara workflow-filer ändrats
            if grep -q "\.github/workflows/" changed_files.txt; then
              echo "Bara workflow-filer ändrades, kör inte infrastrukturjobb"
            fi
          fi

          echo "changes_detected=$changes_detected" >> $GITHUB_OUTPUT

          # Skapa sammanfattning
          summary="Ändringar upptäckta:\n"
          summary+="  Infrastruktur: $bicep_changes\n"
          summary+="  Konfiguration: $ansible_changes\n"
          summary+="  Webbapplikation: $webapp_changes\n"
          echo "change_summary=$summary" >> $GITHUB_OUTPUT

          # Skriv ut ändringar för loggen
          echo "==================== ÄNDRINGSDETEKTERING SAMMANFATTNING ===================="
          echo -e "$summary"
          echo "================================================================="

      - name: Debug outputs
        run: |
          echo "Final output values:"
          echo "run_bicep=${{ steps.check_files.outputs.run_bicep }}"
          echo "run_ansible=${{ steps.check_files.outputs.run_ansible }}"
          echo "run_webapp=${{ steps.check_files.outputs.run_webapp }}"
          echo "changes_detected=${{ steps.check_files.outputs.changes_detected }}"



  # ===========================================================================================
  # =============================Get Existing Infrastructure Info==============================
  # ===========================================================================================



  get-infrastructure-info:
    name: Get Existing Infrastructure Info
    needs: check-changes
    if: ${{ needs.check-changes.outputs.changes_detected == 'true' && needs.check-changes.outputs.run_bicep != 'true' || (github.event_name == 'workflow_dispatch' && github.event.inputs.full_deployment == 'true' && github.event.inputs.skip_bicep == 'true') }}
    runs-on: ubuntu-latest
    outputs:
      BASTION_IP: ${{ steps.get_infrastructure_data.outputs.BASTION_IP }}
      APP_IP: ${{ steps.get_infrastructure_data.outputs.APP_IP }}
      MONGODB_CONNECTION_STRING: ${{ steps.get_infrastructure_data.outputs.MONGODB_CONNECTION_STRING }}
      MONGODB_CONNECTION_STRING_B64: ${{ steps.get_infrastructure_data.outputs.MONGODB_CONNECTION_STRING_B64 }}
      STORAGE_ACCOUNT: ${{ steps.get_infrastructure_data.outputs.STORAGE_ACCOUNT }}
      BLOB_ENDPOINT: ${{ steps.get_infrastructure_data.outputs.BLOB_ENDPOINT }}
      RUNNER_TOKEN: ${{ steps.generate_token.outputs.RUNNER_TOKEN }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Azure Login
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      # Use our reusable SSH setup
      - name: Set up SSH keys
        uses: ./.github/actions/setup-ssh
        with:
          ssh_private_key: ${{ secrets.SSH_PRIVATE_KEY }}

      # Generate a new runner token
      - name: Generate runner token
        id: generate_token
        run: |
          TOKEN=$(curl -X POST -H "Authorization: token ${{ secrets.PAT_TOKEN }}" \
            -H "Accept: application/vnd.github+json" \
            https://api.github.com/repos/${{ env.REPO_NAME }}/actions/runners/registration-token \
            | jq -r .token)

          # Set the token as environment variable and output.
          echo "RUNNER_TOKEN=$TOKEN" >> $GITHUB_ENV
          echo "RUNNER_TOKEN=$TOKEN" >> $GITHUB_OUTPUT
          echo "::add-mask::$TOKEN"

          # Check if the token is available.
          # echo "Debug: Runner token"
          # echo "PAT token available: ${{ secrets.PAT_TOKEN != '' }}"
          # echo "Runner token available: $([[ -n "$TOKEN" ]] && echo "Yes" || echo "No")"
          # echo "REPO_NAME: ${{ env.REPO_NAME }}"

      # Get the infrastructure info from Azure
      - name: Get Infrastructure Data
        id: get_infrastructure_data
        run: |
          echo "Getting Bastion IP..."
          BASTION_IP=$(az deployment group show \
            --resource-group ${{ env.RESOURCE_GROUP }} \
            --name main \
            --query "properties.outputs.bastionHostIp.value" \
            --output tsv 2>/dev/null) || BASTION_IP=""

          if [ -z "$BASTION_IP" ]; then
            # Try to find the bastion VM/IP directly if deployment output is not available
            BASTION_IP=$(az vm list-ip-addresses \
              --resource-group ${{ env.RESOURCE_GROUP }} \
              --name "${{ env.PROJECT_NAME }}-bastion-vm" \
              --query "[0].virtualMachine.network.publicIpAddresses[0].ipAddress" \
              --output tsv 2>/dev/null) || BASTION_IP=""
          fi

          echo "Getting App server IP..."
          APP_IP=$(az deployment group show \
            --resource-group ${{ env.RESOURCE_GROUP }} \
            --name main \
            --query "properties.outputs.appServerPrivateIp.value" \
            --output tsv 2>/dev/null) || APP_IP=""

          if [ -z "$APP_IP" ]; then
            # Try to find the app VM/IP directly
            APP_IP=$(az vm list-ip-addresses \
              --resource-group ${{ env.RESOURCE_GROUP }} \
              --name "${{ env.PROJECT_NAME }}-app-vm" \
              --query "[0].virtualMachine.network.privateIpAddresses[0]" \
              --output tsv 2>/dev/null) || APP_IP=""
          fi

          echo "Getting storage account name..."
          STORAGE_ACCOUNT=$(az deployment group show \
            --resource-group ${{ env.RESOURCE_GROUP }} \
            --name main \
            --query "properties.outputs.storageAccountName.value" \
            --output tsv 2>/dev/null) || STORAGE_ACCOUNT=""

          if [ -z "$STORAGE_ACCOUNT" ]; then
            # Try to find storage account directly
            STORAGE_ACCOUNT=$(az storage account list \
              --resource-group ${{ env.RESOURCE_GROUP }} \
              --query "[?starts_with(name, '${{ env.PROJECT_NAME }}')].name" \
              --output tsv 2>/dev/null | head -1) || STORAGE_ACCOUNT=""
          fi

          echo "Getting blob endpoint..."
          if [ -n "$STORAGE_ACCOUNT" ]; then
            BLOB_ENDPOINT=$(az storage account show \
              --resource-group ${{ env.RESOURCE_GROUP }} \
              --name $STORAGE_ACCOUNT \
              --query "primaryEndpoints.blob" \
              --output tsv 2>/dev/null) || BLOB_ENDPOINT=""
          else
            BLOB_ENDPOINT=""
          fi

          # Check and display what we found
          echo "Found resources:"
          echo "Bastion IP: $BASTION_IP"
          echo "App IP: $APP_IP"
          echo "Storage Account: $STORAGE_ACCOUNT"
          echo "Blob Endpoint: $BLOB_ENDPOINT"
          echo "MongoDB connection string found: $([ -n "$MONGODB_CONNECTION_STRING" ] && echo "Yes" || echo "No")"

          # Set the outputs for subsequent jobs
          echo "BASTION_IP=$BASTION_IP" >> $GITHUB_OUTPUT
          echo "APP_IP=$APP_IP" >> $GITHUB_OUTPUT
          echo "MONGODB_CONNECTION_STRING=$MONGODB_CONNECTION_STRING" >> $GITHUB_OUTPUT
          echo "STORAGE_ACCOUNT=$STORAGE_ACCOUNT" >> $GITHUB_OUTPUT
          echo "BLOB_ENDPOINT=$BLOB_ENDPOINT" >> $GITHUB_OUTPUT

          # Base64 encode MongoDB connection string if it exists
          if [ -n "$MONGODB_CONNECTION_STRING" ] && [ ${#MONGODB_CONNECTION_STRING} -gt 20 ]; then
            MONGODB_CONNECTION_STRING_B64=$(echo -n "$MONGODB_CONNECTION_STRING" | base64 -w0)
            echo "MONGODB_CONNECTION_STRING_B64=$MONGODB_CONNECTION_STRING_B64" >> $GITHUB_OUTPUT
            echo "Encoded MongoDB connection string (first 10 chars): ${MONGODB_CONNECTION_STRING_B64:0:10}..."
          else
            echo "Warning: MongoDB connection string not found or too short"
          fi



  # ===========================================================================================
  # ==============================Deploy Azure Infrastructure==================================
  # ===========================================================================================



  # Check if dotnet app files were changed.
  deploy-infrastructure:
    name: Deploy Azure Infrastructure
    needs: [check-changes]
    if: ${{ needs.check-changes.outputs.run_bicep == 'true' || (github.event_name == 'workflow_dispatch' && github.event.inputs.full_deployment == 'true' && github.event.inputs.skip_bicep != 'true') }}
    runs-on: ubuntu-latest
    outputs:
      BASTION_IP: ${{ steps.deployment_data.outputs.BASTION_IP }}
      APP_IP: ${{ steps.deployment_data.outputs.APP_IP }}
      MONGODB_CONNECTION_STRING: ${{ steps.deployment_data.outputs.MONGODB_CONNECTION_STRING }}
      MONGODB_CONNECTION_STRING_B64: ${{ steps.deployment_data.outputs.MONGODB_CONNECTION_STRING_B64 }}
      STORAGE_ACCOUNT: ${{ steps.deployment_data.outputs.STORAGE_ACCOUNT }}
      BLOB_ENDPOINT: ${{ steps.deployment_data.outputs.BLOB_ENDPOINT }}
      RUNNER_TOKEN: ${{ steps.generate_token.outputs.RUNNER_TOKEN }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Azure Login
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      # Use our reusable SSH setup
      - name: Set up SSH keys
        uses: ./.github/actions/setup-ssh
        with:
          ssh_private_key: ${{ secrets.SSH_PRIVATE_KEY }}

      # Generate a new runner token
      - name: Generate runner token
        id: generate_token
        run: |
          TOKEN=$(curl -X POST -H "Authorization: token ${{ secrets.PAT_TOKEN }}" \
            -H "Accept: application/vnd.github+json" \
            https://api.github.com/repos/${{ env.REPO_NAME }}/actions/runners/registration-token \
            | jq -r .token)

          # Set the token as environment variable and output.
          echo "RUNNER_TOKEN=$TOKEN" >> $GITHUB_ENV
          echo "RUNNER_TOKEN=$TOKEN" >> $GITHUB_OUTPUT
          echo "::add-mask::$TOKEN"

          # Check if the token is available.
          echo "Debug: Runner token"
          echo "PAT token available: ${{ secrets.PAT_TOKEN != '' }}"
          echo "Runner token available: $([[ -n "$TOKEN" ]] && echo "Yes" || echo "No")"
          echo "REPO_NAME: ${{ env.REPO_NAME }}"

      # Deploy the infrastructure using Bicep
      - name: Deploy Infrastructure
        id: deploy
        uses: azure/arm-deploy@v1
        with:
          scope: resourcegroup
          resourceGroupName: ${{ env.RESOURCE_GROUP }}
          template: ./infrastructure/bicep/main.bicep
          parameters: >
            projectName=${{ env.PROJECT_NAME }}
            adminUsername=azureuser
            sshPublicKey="${{ secrets.SSH_PUBLIC_KEY }}"
            location=${{ env.LOCATION }}
          deploymentName: main

      # Get the outputs from the deployment
      - name: Get Deployment Outputs
        id: deployment_data
        run: |

          echo "Getting Bastion IP..."
          BASTION_IP=$(az deployment group show \
            --resource-group ${{ env.RESOURCE_GROUP }} \
            --name main \
            --query "properties.outputs.bastionHostIp.value" \
            --output tsv)

          # Check if the bastion IP is available
          echo "Bastion IP available: $([[ -n "$BASTION_IP" ]] && echo "Yes" || echo "No")"

          # Debug: Print the Bastion IP
          echo "Bastion IP: $BASTION_IP"

          echo "Getting App server IP..."
          APP_IP=$(az deployment group show \
            --resource-group ${{ env.RESOURCE_GROUP }} \
            --name main \
            --query "properties.outputs.appServerPrivateIp.value" \
            --output tsv)

          # Check if the app IP is available
          echo "App IP available: $([[ -n "$APP_IP" ]] && echo "Yes" || echo "No")"

          # Debug: Print the App IP
          echo "App IP: $APP_IP"

          echo "Getting MongoDB connection string..."
          MONGODB_CONNECTION_STRING=$(az deployment group show \
            --resource-group ${{ env.RESOURCE_GROUP }} \
            --name main \
            --query "properties.outputs.mongoDbConnectionString.value" \
            --output tsv)

          # debug: Print the MongoDB connection string
          echo "Available outputs:"
            az deployment group show \
              --resource-group ${{ env.RESOURCE_GROUP }} \
              --name main \
              --query "properties.outputs" \
              --output json

          # Check if the connection string is available
          echo "Connection string available: $([[ -n "$MONGODB_CONNECTION_STRING" ]] && echo "Yes" || echo "No")"

          # Debug: Print the MongoDB connection string
          echo "MongoDB connection string: $MONGODB_CONNECTION_STRING"

          echo "Getting storage account name..."
          STORAGE_ACCOUNT=$(az deployment group show \
            --resource-group ${{ env.RESOURCE_GROUP }} \
            --name main \
            --query "properties.outputs.storageAccountName.value" \
            --output tsv)

          # Check if the storage account is available
          echo "Storage account available: $([[ -n "$STORAGE_ACCOUNT" ]] && echo "Yes" || echo "No")"

          # Debug: Print the storage account name
          echo "Storage account: $STORAGE_ACCOUNT"

          echo "Getting blob endpoint..."
          BLOB_ENDPOINT=$(az deployment group show \
            --resource-group ${{ env.RESOURCE_GROUP }} \
            --name main \
            --query "properties.outputs.blobEndpoint.value" \
            --output tsv)

          # Check if the blob endpoint is available
          echo "Blob endpoint available: $([[ -n "$BLOB_ENDPOINT" ]] && echo "Yes" || echo "No")"

          # Debug: Print the Blob endpoint
          echo "Blob endpoint: $BLOB_ENDPOINT"

          # Set the environment variables.
          echo "BASTION_IP=$BASTION_IP" >> $GITHUB_ENV
          echo "APP_IP=$APP_IP" >> $GITHUB_ENV
          echo "MONGODB_CONNECTION_STRING=$MONGODB_CONNECTION_STRING" >> $GITHUB_ENV
          echo "STORAGE_ACCOUNT=$STORAGE_ACCOUNT" >> $GITHUB_ENV
          echo "BLOB_ENDPOINT=$BLOB_ENDPOINT" >> $GITHUB_ENV

          # Set the outputs for subsequent jobs.
          echo "BASTION_IP=$BASTION_IP" >> $GITHUB_OUTPUT
          echo "APP_IP=$APP_IP" >> $GITHUB_OUTPUT
          echo "MONGODB_CONNECTION_STRING=$MONGODB_CONNECTION_STRING" >> $GITHUB_OUTPUT
          echo "STORAGE_ACCOUNT=$STORAGE_ACCOUNT" >> $GITHUB_OUTPUT
          echo "BLOB_ENDPOINT=$BLOB_ENDPOINT" >> $GITHUB_OUTPUT

          # Base64 encode MongoDB connection string
          if [ -n "$MONGODB_CONNECTION_STRING" ] && [ ${#MONGODB_CONNECTION_STRING} -gt 20 ]; then
            MONGODB_CONNECTION_STRING_B64=$(echo -n "$MONGODB_CONNECTION_STRING" | base64 -w0)
            echo "MONGODB_CONNECTION_STRING_B64=$MONGODB_CONNECTION_STRING_B64" >> $GITHUB_ENV
            echo "MONGODB_CONNECTION_STRING_B64=$MONGODB_CONNECTION_STRING_B64" >> $GITHUB_OUTPUT
            echo "Encoded MongoDB connection string (first 10 chars): ${MONGODB_CONNECTION_STRING_B64:0:10}..."
          else
            echo "Warning: Invalid MongoDB connection string, length: ${#MONGODB_CONNECTION_STRING}"
          fi

      - name: Ensure Ansible config exists
        run: |
          mkdir -p ./ansible
          echo "[defaults]" > ./ansible/ansible.cfg
          echo "host_key_checking = False" >> ./ansible/ansible.cfg
          echo "roles_path = ./ansible/roles" >> ./ansible/ansible.cfg

          # Set the environment variable
          echo "ANSIBLE_CONFIG=./ansible/ansible.cfg" >> $GITHUB_ENV

          # Debug directory structure
          echo "Directory structure:"
          find ./ansible -type d | sort

      - name: Test SSH connectivity
        run: |

          # Test SSH to bastion
          echo "Testing SSH to bastion host at $BASTION_IP..."
          ssh -i ~/.ssh/clofresva_gc_upg02_azure_key -o ConnectTimeout=10 azureuser@$BASTION_IP "echo 'Bastion connection successful!'" || echo "WARNING: Bastion connection failed!"

          # Test SSH to app server via bastion
          echo "Testing SSH to app server at $APP_IP via bastion..."
          ssh -i ~/.ssh/clofresva_gc_upg02_azure_key -o ConnectTimeout=10 -o ProxyCommand="ssh -W %h:%p -i ~/.ssh/clofresva_gc_upg02_azure_key azureuser@$BASTION_IP" azureuser@$APP_IP "echo 'App server connection successful!'" || echo "WARNING: App server connection failed!"



  # ===========================================================================================
  # ==============================Configure Servers with Ansible===============================
  # ===========================================================================================



  configure-servers:
    name: Configure Servers with Ansible
    needs: [check-changes, deploy-infrastructure, get-infrastructure-info]
    if: ${{ needs.check-changes.outputs.run_ansible == 'true' || (github.event_name == 'workflow_dispatch' && github.event.inputs.full_deployment == 'true' && github.event.inputs.skip_ansible != 'true') }}
    runs-on: ubuntu-latest
    env:
      BASTION_IP: ${{ needs.deploy-infrastructure.outputs.BASTION_IP != '' && needs.deploy-infrastructure.outputs.BASTION_IP || needs.get-infrastructure-info.outputs.BASTION_IP }}
      APP_IP: ${{ needs.deploy-infrastructure.outputs.APP_IP != '' && needs.deploy-infrastructure.outputs.APP_IP || needs.get-infrastructure-info.outputs.APP_IP }}
      MONGODB_CONNECTION_STRING: ${{ needs.deploy-infrastructure.outputs.MONGODB_CONNECTION_STRING != '' && needs.deploy-infrastructure.outputs.MONGODB_CONNECTION_STRING || needs.get-infrastructure-info.outputs.MONGODB_CONNECTION_STRING }}
      MONGODB_CONNECTION_STRING_B64: ${{ needs.deploy-infrastructure.outputs.MONGODB_CONNECTION_STRING_B64 != '' && needs.deploy-infrastructure.outputs.MONGODB_CONNECTION_STRING_B64 || needs.get-infrastructure-info.outputs.MONGODB_CONNECTION_STRING_B64 }}
      STORAGE_ACCOUNT: ${{ needs.deploy-infrastructure.outputs.STORAGE_ACCOUNT != '' && needs.deploy-infrastructure.outputs.STORAGE_ACCOUNT || needs.get-infrastructure-info.outputs.STORAGE_ACCOUNT }}
      BLOB_ENDPOINT: ${{ needs.deploy-infrastructure.outputs.BLOB_ENDPOINT != '' && needs.deploy-infrastructure.outputs.BLOB_ENDPOINT || needs.get-infrastructure-info.outputs.BLOB_ENDPOINT }}
      RUNNER_TOKEN: ${{ needs.deploy-infrastructure.outputs.RUNNER_TOKEN != '' && needs.deploy-infrastructure.outputs.RUNNER_TOKEN || needs.get-infrastructure-info.outputs.RUNNER_TOKEN }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      # Använd vår återanvändbara SSH-uppsättning
      - name: Set up SSH keys
        uses: ./.github/actions/setup-ssh
        with:
          ssh_private_key: ${{ secrets.SSH_PRIVATE_KEY }}

      - name: Debug environment variables
        run: |
          echo "RUNNER_TOKEN from output: ${{ needs.deploy-infrastructure.outputs.RUNNER_TOKEN != '' }}"
          echo "RUNNER_TOKEN from env: $([[ -n \"$RUNNER_TOKEN\" ]] && echo 'Yes' || echo 'No')"

      - name: Ensure Ansible config exists
        run: |
          mkdir -p ./ansible
          echo "[defaults]" > ./ansible/ansible.cfg
          echo "host_key_checking = False" >> ./ansible/ansible.cfg
          echo "roles_path = ./ansible/roles" >> ./ansible/ansible.cfg

          # Set the environment variable
          echo "ANSIBLE_CONFIG=./ansible/ansible.cfg" >> $GITHUB_ENV

          # Debug directory structure
          echo "Directory structure:"
          find ./ansible -type d | sort

      - name: Test SSH connectivity
        run: |
          # Check if environment variables are available
          if [ -z "${{ env.APP_IP }}" ] || [ -z "${{ env.BASTION_IP }}" ]; then
            echo "WARNING: IP addresses not set. Using hardcoded values."
            APP_IP="10.0.2.4"
            BASTION_IP="137.116.232.168"
          else
            APP_IP="${{ env.APP_IP }}"
            BASTION_IP="${{ env.BASTION_IP }}"
          fi

          # Test SSH to bastion
          echo "Testing SSH to bastion host at $BASTION_IP..."
          ssh -i ~/.ssh/clofresva_gc_upg02_azure_key -o ConnectTimeout=10 azureuser@$BASTION_IP "echo 'Bastion connection successful!'" || echo "WARNING: Bastion connection failed!"

          # Test SSH to app server via bastion
          echo "Testing SSH to app server at $APP_IP via bastion..."
          ssh -i ~/.ssh/clofresva_gc_upg02_azure_key -o ConnectTimeout=10 -o ProxyCommand="ssh -W %h:%p -i ~/.ssh/clofresva_gc_upg02_azure_key azureuser@$BASTION_IP" azureuser@$APP_IP "echo 'App server connection successful!'" || echo "WARNING: App server connection failed!"

      # Run Ansible to configure servers
      - name: Run Ansible
        run: |
          # Create ansible inventory directory
          mkdir -p ./ansible/inventories

          # Check if environment variables are available
          if [ -z "${{ env.APP_IP }}" ] || [ -z "${{ env.BASTION_IP }}" ]; then
            echo "WARNING: IP addresses not set. Using hardcoded values."
            APP_IP="10.0.2.4"
            BASTION_IP="137.116.232.168"
          else
            APP_IP="${{ env.APP_IP }}"
            BASTION_IP="${{ env.BASTION_IP }}"
          fi

          echo "Using App IP: $APP_IP"
          echo "Using Bastion IP: $BASTION_IP"

          # Skapa inventory-fil
          echo "all:" > ./ansible/inventories/azure_rm.yaml
          echo "  hosts:" >> ./ansible/inventories/azure_rm.yaml
          echo "    app_server:" >> ./ansible/inventories/azure_rm.yaml
          echo "      ansible_host: $APP_IP" >> ./ansible/inventories/azure_rm.yaml
          echo "      ansible_user: azureuser" >> ./ansible/inventories/azure_rm.yaml
          echo "      ansible_ssh_private_key_file: ~/.ssh/clofresva_gc_upg02_azure_key" >> ./ansible/inventories/azure_rm.yaml

          # ProxyCommand för att nå app-servern via bastion
          echo "      ansible_ssh_common_args: '-o ProxyCommand=ssh -W %h:%p -i ~/.ssh/clofresva_gc_upg02_azure_key azureuser@$BASTION_IP -p 2222'" >> ./ansible/inventories/azure_rm.yaml

          echo "  vars:" >> ./ansible/inventories/azure_rm.yaml
          echo "    project_name: ${{ env.PROJECT_NAME }}" >> ./ansible/inventories/azure_rm.yaml
          echo "    storage_account: ${{ env.STORAGE_ACCOUNT }}" >> ./ansible/inventories/azure_rm.yaml
          echo "    blob_endpoint: ${{ env.BLOB_ENDPOINT }}" >> ./ansible/inventories/azure_rm.yaml
          echo "    container_name: appdata" >> ./ansible/inventories/azure_rm.yaml
          echo "    github_repo: ${{ env.REPO_NAME }}" >> ./ansible/inventories/azure_rm.yaml
          echo "    github_runner_token: ***" >> ./ansible/inventories/azure_rm.yaml

          # Debug - visa inventory med maskerat token
          echo "Generated inventory file (sensitive data masked):"
          cat ./ansible/inventories/azure_rm.yaml | sed 's/github_runner_token: .*/github_runner_token: ***/' | sed 's/mongodb_connection_string_base64: .*/mongodb_connection_string_base64: ***/'

          # Säkert sätt att lägga till token i filen
          sed -i "s/github_runner_token: \*\*\*/github_runner_token: ${{ env.RUNNER_TOKEN }}/" ./ansible/inventories/azure_rm.yaml

          # Använd base64 för att undvika problem med specialtecken
          echo "    mongodb_connection_string_base64: ${{ env.MONGODB_CONNECTION_STRING_B64 }}" >> ./ansible/inventories/azure_rm.yaml

          # Debug - visa inventory med maskerat token
          echo "Generated inventory file (sensitive data masked):"
          cat ./ansible/inventories/azure_rm.yaml | sed 's/github_runner_token: .*/github_runner_token: ***/' | sed 's/mongodb_connection_string_base64: .*/mongodb_connection_string_base64: ***/'

          echo "Waiting for SSH to be available..."
          sleep 30

          # Kör Ansible en gång med error-hantering
          echo "Running Ansible with error handling..."
          if ! ansible-playbook -i ./ansible/inventories/azure_rm.yaml ./ansible/playbooks/app-server.yaml; then
            echo "::warning::Ansible playbook failed but workflow will continue"
            echo "ansible_failed=true" >> $GITHUB_ENV
          else
            echo "ansible_failed=false" >> $GITHUB_ENV
          fi
        continue-on-error: true # Continue even if Ansible fails



  # ===========================================================================================
  # =============================Deploy Application as Artifact===============================
  # ===========================================================================================



  # Build and deploy the dotnet app as an artifact and upload, if files were changed.
  deploy-app:
    name: Deploy Application as Artifact
    needs: [check-changes, get-infrastructure-info, configure-servers]
    if: ${{ needs.check-changes.outputs.run_webapp == 'true' || (github.event_name == 'workflow_dispatch' && github.event.inputs.full_deployment == 'true') }}
    runs-on: ubuntu-latest
    env:
      BASTION_IP: ${{ needs.deploy-infrastructure.outputs.BASTION_IP != '' && needs.deploy-infrastructure.outputs.BASTION_IP || needs.get-infrastructure-info.outputs.BASTION_IP }}
      APP_IP: ${{ needs.deploy-infrastructure.outputs.APP_IP != '' && needs.deploy-infrastructure.outputs.APP_IP || needs.get-infrastructure-info.outputs.APP_IP }}

    steps:
      # Check out the code from the repository
      - name: Checkout code
        uses: actions/checkout@v4

      # Använd vår återanvändbara SSH-uppsättning
      - name: Set up SSH keys
        uses: ./.github/actions/setup-ssh
        with:
          ssh_private_key: ${{ secrets.SSH_PRIVATE_KEY }}

      # Set up .NET SDK
      - name: Setup .NET
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: 9.0.x

      # Build the web application
      - name: Build Web App
        run: |
          # Backup existing app if it exists (via SSH) if setup failed.
          if [ "${{ env.APP_IP }}" != "" ] && [ "${{ env.BASTION_IP }}" != "" ]; then
            echo "Creating backup of existing app..."
            ssh -o ConnectTimeout=10 -o ProxyCommand="ssh -W %h:%p -i ~/.ssh/clofresva_gc_upg02_azure_key azureuser@$BASTION_IP" -i ~/.ssh/clofresva_gc_upg02_azure_key azureuser@$APP_IP "
              if [ -d /var/www/app ]; then
                sudo cp -r /var/www/app /var/www/app_backup_$(date +%Y%m%d_%H%M%S)
              fi
            " || echo "Could not create backup, continuing anyway"
          fi

          # Build app as normal
          dotnet publish ./WebbApp/MVC_TestApp.csproj -c Release -o ./publish

          # Verify published files
          echo "Listing published files:"
          ls -la ./publish/

          # Controll that the .dll file exists
          if [ -f "./publish/MVC_TestApp.dll" ]; then
            echo "MVC_TestApp.dll found!"
          else
            echo "WARNING: MVC_TestApp.dll NOT found!"
            echo "Files in directory:"
            find ./publish -name "*.dll"
          fi

      # Add a timestamp to the deployment for use in the app.
      - name: Add deploy timestamp
        run: |
          # Säkerställ att wwwroot-katalogen finns
          mkdir -p ./publish/wwwroot
          echo "$(date -u +"%Y-%m-%d %H:%M:%S")" > ./publish/wwwroot/deploy-timestamp.txt

      # Deploy the application to the server
      - name: Verify deployment
        run: |
          # Check if environment variables are available
          if [ -z "${{ env.APP_IP }}" ] || [ -z "${{ env.BASTION_IP }}" ]; then
            echo "WARNING: IP addresses not set. Using hardcoded values."
            APP_IP="10.0.2.4"
            BASTION_IP="137.116.232.168"
          else
            APP_IP="${{ env.APP_IP }}"
            BASTION_IP="${{ env.BASTION_IP }}"
          fi

          echo "Verifying deployment..."
          # Wait 10 seconds for the service to stabilize
          sleep 10

          # Check service status
          ssh -o ConnectTimeout=10 -o ProxyCommand="ssh -W %h:%p -i ~/.ssh/clofresva_gc_upg02_azure_key azureuser@$BASTION_IP" -i ~/.ssh/clofresva_gc_upg02_azure_key azureuser@$APP_IP "
            echo 'Service status:'
            sudo systemctl status webapp.service || true

            echo 'Running processes:'
            ps aux | grep dotnet

            echo 'Service logs:'
            sudo journalctl -u webapp.service --no-pager -n 20 || true
          "

      # Upload the artifact to the server
      - name: Upload App Artifact
        uses: actions/upload-artifact@v4
        with:
          name: webapp
          path: ./publish
          retention-days: 1



  # ===========================================================================================
  # ==============================Deploy Artifact to App-Server================================
  # ===========================================================================================
  # Deploy the artifact to the app server.
  deploy-to-server:
    name: Deploy Artifact to App-Server
    needs: [deploy-app, get-infrastructure-info, configure-servers]
    if: ${{ needs.check-changes.outputs.run_webapp == 'true' || (github.event_name == 'workflow_dispatch' && github.event.inputs.full_deployment == 'true') }}
    runs-on: ubuntu-latest
    env:
      BASTION_IP: ${{ needs.deploy-infrastructure.outputs.BASTION_IP != '' && needs.deploy-infrastructure.outputs.BASTION_IP || needs.get-infrastructure-info.outputs.BASTION_IP }}

      APP_IP: ${{ needs.deploy-infrastructure.outputs.APP_IP != '' && needs.deploy-infrastructure.outputs.APP_IP || needs.get-infrastructure-info.outputs.APP_IP }}

      MONGODB_CONNECTION_STRING: ${{ needs.deploy-infrastructure.outputs.MONGODB_CONNECTION_STRING != '' && needs.deploy-infrastructure.outputs.MONGODB_CONNECTION_STRING || needs.get-infrastructure-info.outputs.MONGODB_CONNECTION_STRING }}

      MONGODB_CONNECTION_STRING_B64: ${{ needs.deploy-infrastructure.outputs.MONGODB_CONNECTION_STRING_B64 != '' && needs.deploy-infrastructure.outputs.MONGODB_CONNECTION_STRING_B64 || needs.get-infrastructure-info.outputs.MONGODB_CONNECTION_STRING_B64 }}

      STORAGE_ACCOUNT: ${{ needs.deploy-infrastructure.outputs.STORAGE_ACCOUNT != '' && needs.deploy-infrastructure.outputs.STORAGE_ACCOUNT || needs.get-infrastructure-info.outputs.STORAGE_ACCOUNT }}

      BLOB_ENDPOINT: ${{ needs.deploy-infrastructure.outputs.BLOB_ENDPOINT != '' && needs.deploy-infrastructure.outputs.BLOB_ENDPOINT || needs.get-infrastructure-info.outputs.BLOB_ENDPOINT }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      # Use the SSH setup action.
      - name: Set up SSH keys
        uses: ./.github/actions/setup-ssh
        with:
          ssh_private_key: ${{ secrets.SSH_PRIVATE_KEY }}

      - name: Debug SSH configuration
        run: |
          # echo "SSH directory contents:"
          # ls -la ~/.ssh/

          # echo "SSH config file:"
          # cat ~/.ssh/config

          # Check if environment variables are available
          if [ -z "${{ env.APP_IP }}" ] || [ -z "${{ env.BASTION_IP }}" ]; then
            echo "WARNING: IP addresses not set. Using hardcoded values."
            APP_IP="10.0.2.4"
            BASTION_IP="137.116.232.168"
          else
            APP_IP="${{ env.APP_IP }}"
            BASTION_IP="${{ env.BASTION_IP }}"
          fi

          echo "Testing SSH connectivity:"
          echo "Bastion IP: $BASTION_IP"
          ssh -v -i ~/.ssh/clofresva_gc_upg02_azure_key \
            azureuser@$BASTION_IP \
            "echo 'Connected to Bastion'" || echo "Failed to connect to Bastion"

      - name: Download App Artifact
        uses: actions/download-artifact@v4
        with:
          name: webapp
          path: ./webapp-files

      - name: Remove appsettings.json before deployment
        run: |
          echo "Removing appsettings.json from artifact to prevent overriding server configuration..."
          rm -f ./webapp-files/appsettings.json
          # echo "Files after removal:"
          # ls -la ./webapp-files/

      - name: Create target directory and deploy app
        run: |
          echo "Creating webapp-files directory..."
          mkdir -p ./webapp-files

          # Använd endast miljövariabler
          echo "Using App IP: ${{ env.APP_IP }}"
          echo "Using Bastion IP: ${{ env.BASTION_IP }}"

          echo "Creating target directory on remote server..."
          ssh -o ConnectTimeout=10 -o ProxyCommand="ssh -W %h:%p -i ~/.ssh/clofresva_gc_upg02_azure_key azureuser@$BASTION_IP" -i ~/.ssh/clofresva_gc_upg02_azure_key azureuser@$APP_IP "sudo mkdir -p /tmp/webapp && sudo chown azureuser:azureuser /tmp/webapp"

          echo "Copying files to remote server..."
          scp -o ConnectTimeout=10 -o ProxyCommand="ssh -W %h:%p -i ~/.ssh/clofresva_gc_upg02_azure_key azureuser@$BASTION_IP" -i ~/.ssh/clofresva_gc_upg02_azure_key -r ./webapp-files/* azureuser@$APP_IP:/tmp/webapp/

          echo "Deploying files on app server..."
          ssh -o ConnectTimeout=10 -o ProxyCommand="ssh -W %h:%p -i ~/.ssh/clofresva_gc_upg02_azure_key azureuser@$BASTION_IP" -i ~/.ssh/clofresva_gc_upg02_azure_key azureuser@$APP_IP "
            echo 'Deploying application...'
            sudo systemctl stop webapp.service || echo 'Service not running yet'

            echo 'Checking for temporary appsettings file...'
            if [ -f /var/www/app/appsettings-temp.json ]; then
              echo 'Temporary appsettings file exists, will restore after deployment'
              sudo cp /var/www/app/appsettings-temp.json /tmp/appsettings-temp.json
            else
              echo 'No temporary appsettings file found'
            fi

            echo 'Removing old files...'
            sudo rm -rf /var/www/app/*
            sudo mkdir -p /var/www/app

            echo 'Copy files to webapp directory...'
            sudo cp -r /tmp/webapp/* /var/www/app/
            sudo chown -R www-data:www-data /var/www/app

            echo 'Removing appsettings.json and appsettings.Development.json to avoid overrides...'
            sudo rm -f /var/www/app/appsettings.json
            sudo rm -f /var/www/app/appsettings.Development.json

            echo 'Restoring appsettings from temporary file if available...'
            if [ -f /tmp/appsettings-temp.json ]; then
              echo 'Restoring appsettings from previously saved temporary file'
              sudo cp /tmp/appsettings-temp.json /var/www/app/appsettings.json
              sudo chown www-data:www-data /var/www/app/appsettings.json
            else
              echo 'No saved temporary file, trying to run Ansible to create one...'
              sudo ansible-playbook -i /etc/ansible/inventories/local.yaml /etc/ansible/playbooks/restore-config.yaml || true

              # Check if appsettings-temp.json was created by Ansible, if so move it
              if [ -f /var/www/app/appsettings-temp.json ]; then
                echo 'Moving temporary appsettings file to final location'
                sudo mv /var/www/app/appsettings-temp.json /var/www/app/appsettings.json
                sudo chown www-data:www-data /var/www/app/appsettings.json
              else
                echo 'WARNING: Could not create or restore appsettings.json'
              fi
            fi

            # Skapa wwwroot om det inte finns
            sudo mkdir -p /var/www/app/wwwroot
            sudo chown -R www-data:www-data /var/www/app/wwwroot

            echo 'Listing files in webapp directory...'
            ls -la /var/www/app/

            echo 'Restarting service...'
            sudo systemctl daemon-reload
            sudo systemctl restart webapp.service

            echo 'Service status:'
            sudo systemctl status webapp.service || true
            ps aux | grep dotnet

            echo 'Service logs:'
            sudo journalctl -u webapp.service --no-pager -n 50 || true

            echo 'Application deployed!'
          "

      - name: Verify server configuration
        run: |
          echo "Debug miljövariabler:"
          echo "BASTION_IP: ${{ env.BASTION_IP }}"
          echo "APP_IP: ${{ env.APP_IP }}"

          if [ -z "${{ env.APP_IP }}" ] || [ -z "${{ env.BASTION_IP }}" ]; then
            echo "ERROR: IP-adresser saknas. Kan inte fortsätta utan korrekt infrastrukturdata."
            exit 1
          fi

          echo "Verifierar serverkonfiguration..."
          ssh -o ConnectTimeout=10 -o ProxyCommand="ssh -W %h:%p -i ~/.ssh/clofresva_gc_upg02_azure_key azureuser@${{ env.BASTION_IP }}" -i ~/.ssh/clofresva_gc_upg02_azure_key azureuser@${{ env.APP_IP }} "
            echo 'Kontrollerar serverkonfiguration...'

            if [ ! -f /var/www/app/appsettings.json ]; then
              echo 'ERROR: appsettings.json saknas helt!'
              exit 0
            fi

            if grep -q '{accountname}' /var/www/app/appsettings.json; then
              echo 'VARNING: Standardplaceholders upptäckta i appsettings.json, försöker återställa från mall'

              if [ -f /var/www/app/appsettings-temp.json ]; then
                echo 'Hittade en temporär appsettings fil, använder den'
                sudo mv /var/www/app/appsettings-temp.json /var/www/app/appsettings.json
                sudo chown www-data:www-data /var/www/app/appsettings.json
              else
                echo 'Ingen temporär fil, kör Ansible för att skapa en'
                sudo ansible-playbook -i /etc/ansible/inventories/local.yaml /etc/ansible/playbooks/restore-config.yaml || echo 'Ansible misslyckades'

                if [ -f /var/www/app/appsettings-temp.json ]; then
                  echo 'Flyttar temporär appsettings fil till slutlig plats'
                  sudo mv /var/www/app/appsettings-temp.json /var/www/app/appsettings.json
                  sudo chown www-data:www-data /var/www/app/appsettings.json
                fi
              fi

              # Verifiera efter försök till åtgärd
              if grep -q '{accountname}' /var/www/app/appsettings.json; then
                echo 'ERROR: Kunde fortfarande inte ersätta placeholders!'
                cat /var/www/app/appsettings.json || echo 'Kunde inte visa innehåll'
              else
                echo 'Framgångsrikt återställt konfiguration'
                echo 'Startar om tjänsten för att tillämpa nya inställningar'
                sudo systemctl restart webapp.service
              fi
            else
              echo 'Serverkonfiguration ser korrekt ut, kontrollerar innehåll (känslig data maskerad):'
              grep -v 'ConnectionString' /var/www/app/appsettings.json || echo 'Kunde inte visa innehåll'
            fi
          "
        continue-on-error: true