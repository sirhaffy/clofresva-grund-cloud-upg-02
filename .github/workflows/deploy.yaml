name: Deploy Infrastructure and Application

on:
  push:
    branches: [ main ]
  workflow_dispatch:
    inputs:
      skip_ansible:
        description: 'Skip Ansible configuration'
        required: false
        default: 'false'
      full_deployment:
        description: 'Run full infrastructure deployment'
        required: false
        default: 'false'

# Environment variables
env:
  PROJECT_NAME: ${{ secrets.PROJECT_NAME }}
  RESOURCE_GROUP: ${{ secrets.RESOURCE_GROUP }}
  LOCATION: northeurope
  REPO_NAME: ${{ secrets.REPO_NAME }}

jobs:
  check-changes:
    name: Check Changes
    runs-on: ubuntu-latest
    outputs:
      run_bicep: ${{ steps.check_files.outputs.run_bicep }}
      run_ansible: ${{ steps.check_files.outputs.run_ansible }}
      run_webapp: ${{ steps.check_files.outputs.run_webapp }}
      changes_detected: ${{ steps.check_files.outputs.changes_detected }}
      change_summary: ${{ steps.check_files.outputs.change_summary }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 2

      - name: Check changed files
        id: check_files
        run: |
          # Implementation remains the same as your original workflow

  deploy-infrastructure:
    name: Deploy Azure Infrastructure
    needs: check-changes
    if: ${{ needs.check-changes.outputs.run_bicep == 'true' }}
    runs-on: ubuntu-latest
    outputs:
      BASTION_IP: ${{ steps.get_outputs.outputs.BASTION_IP }}
      APP_IP: ${{ steps.get_outputs.outputs.APP_IP }}
      MONGODB_CONNECTION_STRING: ${{ steps.get_outputs.outputs.MONGODB_CONNECTION_STRING }}
      MONGODB_CONNECTION_STRING_B64: ${{ steps.get_outputs.outputs.MONGODB_CONNECTION_STRING_B64 }}
      STORAGE_ACCOUNT: ${{ steps.get_outputs.outputs.STORAGE_ACCOUNT }}
      BLOB_ENDPOINT: ${{ steps.get_outputs.outputs.BLOB_ENDPOINT }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Azure Login
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      # Use our reusable SSH setup action
      - name: Set up SSH keys
        uses: ./.github/actions/setup-ssh
        with:
          ssh_private_key: ${{ secrets.SSH_PRIVATE_KEY }}

      - name: Generate fresh runner token
        id: generate_token
        run: |
          # Implementation remains the same as your original workflow

      - name: Deploy Infrastructure
        id: deploy
        uses: azure/arm-deploy@v1
        with:
          scope: resourcegroup
          resourceGroupName: ${{ env.RESOURCE_GROUP }}
          template: ./infrastructure/bicep/main.bicep
          parameters: >
            projectName=${{ env.PROJECT_NAME }}
            adminUsername=azureuser
            sshPublicKey="${{ secrets.SSH_PUBLIC_KEY }}"
            location=${{ env.LOCATION }}
          deploymentName: main

      - name: Get Deployment Outputs
        id: get_outputs
        run: |
          # Implementation remains the same as your original workflow

  configure-servers:
    name: Configure Servers with Ansible
    needs: [check-changes, deploy-infrastructure]
    if: ${{
        always() &&
        (needs.check-changes.outputs.run_ansible == 'true' ||
        needs.check-changes.outputs.run_bicep == 'true' ||
        github.event_name == 'workflow_dispatch') &&
        (needs.deploy-infrastructure.result == 'success' || needs.deploy-infrastructure.result == 'skipped')
      }}
    runs-on: ubuntu-latest
    env:
      BASTION_IP: ${{ needs.deploy-infrastructure.outputs.BASTION_IP }}
      APP_IP: ${{ needs.deploy-infrastructure.outputs.APP_IP }}
      MONGODB_CONNECTION_STRING: ${{ needs.deploy-infrastructure.outputs.MONGODB_CONNECTION_STRING }}
      MONGODB_CONNECTION_STRING_B64: ${{ needs.deploy-infrastructure.outputs.MONGODB_CONNECTION_STRING_B64 }}
      STORAGE_ACCOUNT: ${{ needs.deploy-infrastructure.outputs.STORAGE_ACCOUNT }}
      BLOB_ENDPOINT: ${{ needs.deploy-infrastructure.outputs.BLOB_ENDPOINT }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      # Use SSH setup action
      - name: Set up SSH keys
        uses: ./.github/actions/setup-ssh
        with:
          ssh_private_key: ${{ secrets.SSH_PRIVATE_KEY }}
          bastion_ip: ${{ env.BASTION_IP }}
          app_ip: ${{ env.APP_IP }}

      # Generate runner token
      - name: Generate new runner token
        id: generate_token
        run: |
          # Implementation remains the same as your original workflow

      # Use setup-ansible action
      - name: Setup Ansible
        uses: ./.github/actions/setup-ansible
        with:
          bastion_ip: ${{ env.BASTION_IP || '137.116.232.168' }}
          app_ip: ${{ env.APP_IP || '10.0.2.4' }}
          project_name: ${{ env.PROJECT_NAME }}
          storage_account: ${{ env.STORAGE_ACCOUNT }}
          blob_endpoint: ${{ env.BLOB_ENDPOINT }}
          mongodb_connection_string_b64: ${{ env.MONGODB_CONNECTION_STRING_B64 }}
          github_repo: ${{ env.REPO_NAME }}
          github_runner_token: ${{ env.RUNNER_TOKEN }}

      # Run Ansible playbook
      - name: Run Ansible
        run: |
          echo "Running Ansible with error handling..."
          if ! ansible-playbook -i ./ansible/inventories/azure_rm.yaml ./ansible/playbooks/app-server.yaml; then
            echo "::warning::Ansible playbook failed but workflow will continue"
            echo "ansible_failed=true" >> $GITHUB_ENV
          else
            echo "ansible_failed=false" >> $GITHUB_ENV
          fi
        continue-on-error: true

  deploy-app:
    name: Deploy Application as Artifact
    runs-on: ubuntu-latest
    needs: [check-changes, deploy-infrastructure, configure-servers]
    env:
      BASTION_IP: ${{ needs.deploy-infrastructure.outputs.BASTION_IP }}
      APP_IP: ${{ needs.deploy-infrastructure.outputs.APP_IP }}
    if: ${{ always() && needs.check-changes.outputs.run_webapp == 'true' && (needs.deploy-infrastructure.result == 'success' || needs.deploy-infrastructure.result == 'skipped') && (needs.configure-servers.result == 'success' || needs.configure-servers.result == 'skipped') }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up SSH keys
        uses: ./.github/actions/setup-ssh
        with:
          ssh_private_key: ${{ secrets.SSH_PRIVATE_KEY }}
          bastion_ip: ${{ env.BASTION_IP }}
          app_ip: ${{ env.APP_IP }}

      - name: Setup .NET
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: 9.0.x

      - name: Build Web App
        run: |
          # Implementation remains the same as your original workflow

      - name: Add deploy timestamp
        run: |
          mkdir -p ./publish/wwwroot
          echo "$(date -u +"%Y-%m-%d %H:%M:%S")" > ./publish/wwwroot/deploy-timestamp.txt

      - name: Upload App Artifact
        uses: actions/upload-artifact@v4
        with:
          name: webapp
          path: ./publish
          retention-days: 1

  deploy-to-server:
    name: Deploy Artifact to App-Server
    needs: [deploy-app, deploy-infrastructure, configure-servers]
    runs-on: ubuntu-latest
    env:
      BASTION_IP: ${{ needs.deploy-infrastructure.outputs.BASTION_IP }}
      APP_IP: ${{ needs.deploy-infrastructure.outputs.APP_IP }}
    if: ${{ always() && needs.deploy-app.result == 'success' }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up SSH keys
        uses: ./.github/actions/setup-ssh
        with:
          ssh_private_key: ${{ secrets.SSH_PRIVATE_KEY }}
          bastion_ip: ${{ env.BASTION_IP }}
          app_ip: ${{ env.APP_IP }}

      - name: Download App Artifact
        uses: actions/download-artifact@v4
        with:
          name: webapp
          path: ./webapp-files

      - name: Deploy to App Server
        uses: ./.github/actions/deploy-app
        with:
          bastion_ip: ${{ env.BASTION_IP || '137.116.232.168' }}
          app_ip: ${{ env.APP_IP || '10.0.2.4' }}
          app_path: './webapp-files'