name: Deploy Infrastructure and Application

on:
  push:
    branches: [ main ]
  workflow_dispatch:
    inputs:
      skip_ansible:
        description: 'Skip Ansible configuration'
        required: false
        default: 'false'
      full_deployment:
        description: 'Run full infrastructure deployment'
        required: false
        default: 'false'

# Environment variables
env:
  PROJECT_NAME: ${{ secrets.PROJECT_NAME }}
  RESOURCE_GROUP: ${{ secrets.RESOURCE_GROUP }}
  LOCATION: northeurope
  REPO_NAME: ${{ secrets.REPO_NAME }}
  RUNNER_TOKEN: ${{ secrets.RUNNER_TOKEN }}

jobs:

  # Check for changes to determine what needs to be run.
  check-changes:
    name: Check Changed Files
    runs-on: ubuntu-latest
    outputs:
      run_bicep: ${{ steps.filter.outputs.bicep }}
      run_ansible: ${{ steps.filter.outputs.ansible }}
      run_webapp: ${{ steps.filter.outputs.webapp }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Get changed files
        id: changed-files
        uses: tj-actions/changed-files@v44

      - name: Set outputs based on changed files
        id: filter
        run: |
          # Default to not running unless specified or changes detected
          echo "bicep=${{ github.event.inputs.full_deployment == 'true' }}" >> $GITHUB_OUTPUT
          echo "ansible=${{ github.event.inputs.full_deployment == 'true' && github.event.inputs.skip_ansible != 'true' }}" >> $GITHUB_OUTPUT
          echo "webapp=true" >> $GITHUB_OUTPUT  # Default to always run webapp

          # Check each changed file
          for file in ${{ steps.changed-files.outputs.all_changed_files }}; do
            # Infrastructure changes (Bicep)
            if [[ $file == infrastructure/* ]]; then
              echo "bicep=true" >> $GITHUB_OUTPUT
            fi

            # Configuration changes (Ansible)
            if [[ $file == ansible/* ]]; then
              echo "ansible=true" >> $GITHUB_OUTPUT
            fi

            # Workflow changes (might affect both)
            if [[ $file == .github/workflows/* ]]; then
              echo "bicep=true" >> $GITHUB_OUTPUT
              echo "ansible=true" >> $GITHUB_OUTPUT
            fi
          done

          # If explicitly skipping Ansible, override any detection
          if [[ "${{ github.event.inputs.skip_ansible }}" == "true" ]]; then
            echo "ansible=false" >> $GITHUB_OUTPUT
          fi

          # Debug outputs
          echo "Changes detected:"
          echo "  Bicep: ${{ steps.filter.outputs.bicep || 'false' }}"
          echo "  Ansible: ${{ steps.filter.outputs.ansible || 'false' }}"
          echo "  WebApp: ${{ steps.filter.outputs.webapp || 'false' }}"

  # Check if dotnet app files were changed.
  deploy-infrastructure:
    name: Deploy Azure Infrastructure
    needs: check-changes
    if: ${{ needs.check-changes.outputs.run_bicep == 'true' }}
    runs-on: ubuntu-latest
    outputs:
      BASTION_IP: ${{ steps.outputs.outputs.BASTION_IP }}
      APP_IP: ${{ steps.outputs.outputs.APP_IP }}
      MONGODB_CONNECTION_STRING: ${{ steps.outputs.outputs.MONGODB_CONNECTION_STRING }}
      STORAGE_ACCOUNT: ${{ steps.outputs.outputs.STORAGE_ACCOUNT }}
      BLOB_ENDPOINT: ${{ steps.outputs.outputs.BLOB_ENDPOINT }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Azure Login
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Set up SSH keys
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/id_clofresvagcupg02
          chmod 600 ~/.ssh/id_clofresvagcupg02
          ssh-keygen -y -f ~/.ssh/id_clofresvagcupg02 > ~/.ssh/id_clofresvagcupg02.pub

          # Disable strict host key checking
          cat > ~/.ssh/config << EOF
          Host *
            StrictHostKeyChecking no
            UserKnownHostsFile=/dev/null
          EOF
          chmod 600 ~/.ssh/config

      - name: Generate fresh runner token
        id: generate_token
        run: |
          echo "Getting fresh runner token..."
          TOKEN=$(curl -X POST -H "Authorization: token ${{ secrets.PAT_TOKEN }}" \
            -H "Accept: application/vnd.github+json" \
            https://api.github.com/repos/${{ env.REPO_NAME }}/actions/runners/registration-token \
            | jq -r .token)

          echo "RUNNER_TOKEN=$TOKEN" >> $GITHUB_ENV
          echo "Fresh token generated!"

      - name: Deploy Infrastructure
        id: deploy
        uses: azure/arm-deploy@v1
        with:
          scope: resourcegroup
          resourceGroupName: ${{ env.RESOURCE_GROUP }}
          template: ./infrastructure/bicep/main.bicep
          parameters: >
            projectName=${{ env.PROJECT_NAME }}
            adminUsername=azureuser
            sshPublicKey="${{ secrets.SSH_PUBLIC_KEY }}"
            location=${{ env.LOCATION }}
          deploymentName: main

      - name: Get Deployment Outputs
        id: outputs
        run: |
          echo "Getting deployment outputs..."
          DEPLOYMENT_OUTPUTS=$(az deployment group show \
            --resource-group ${{ env.RESOURCE_GROUP }} \
            --name "main" \
            --query properties.outputs -o json)

          # Extract values from outputs
          BASTION_IP=$(echo $DEPLOYMENT_OUTPUTS | jq -r '.bastionHostIp.value')
          PROXY_IP=$(echo $DEPLOYMENT_OUTPUTS | jq -r '.reverseProxyIp.value')
          APP_IP=$(echo $DEPLOYMENT_OUTPUTS | jq -r '.appServerPrivateIp.value')
          STORAGE_ACCOUNT=$(echo $DEPLOYMENT_OUTPUTS | jq -r '.storageAccountName.value')
          BLOB_ENDPOINT=$(echo $DEPLOYMENT_OUTPUTS | jq -r '.blobEndpoint.value')
          MONGODB_CONNECTION_STRING=$(echo $DEPLOYMENT_OUTPUTS | jq -r '.dotNetMongoConnectionString.value // ""')

          # Set environment variables and outputs
          echo "MONGODB_CONNECTION_STRING=$MONGODB_CONNECTION_STRING" >> $GITHUB_ENV
          echo "MONGODB_CONNECTION_STRING=$MONGODB_CONNECTION_STRING" >> $GITHUB_OUTPUT
          echo "BASTION_IP=$BASTION_IP" >> $GITHUB_OUTPUT
          echo "APP_IP=$APP_IP" >> $GITHUB_OUTPUT

      - name: Run Ansible (Only App Server Setup)
        if: ${{ github.event.inputs.skip_ansible != 'true' }}
        run: |
          # Create fresh token for runner.
          echo "Getting fresh runner token and running app server setup (ansible)..."
          cat > ./ansible/inventories/azure_rm.yml << EOF
          all:
            hosts:
              app_server:
                ansible_host: ${{ env.APP_IP }}
                ansible_user: azureuser
                ansible_ssh_private_key_file: ~/.ssh/id_clofresvagcupg02
                ansible_ssh_common_args: '-o ProxyCommand="ssh -W %h:%p -i ~/.ssh/id_clofresvagcupg02 azureuser@${{ env.BASTION_IP }}"'
            vars:
              project_name: ${{ env.PROJECT_NAME }}
              storage_account: ${{ env.STORAGE_ACCOUNT }}
              blob_endpoint: ${{ env.BLOB_ENDPOINT }}
              github_repo: ${{ env.REPO_NAME }}
              github_runner_token: ${{ env.RUNNER_TOKEN }}
              mongodb_connection_string: ${{ env.MONGODB_CONNECTION_STRING }}
          EOF

          echo "Waiting for SSH to be available..."
          sleep 60

          # Endast köra app-server playbook istället för site.yml som innehåller allt
          ansible-playbook -i ./ansible/inventories/azure_rm.yml ./ansible/playbooks/app-server.yml || echo "Ansible problem encountered, continuing with app deployment"


  configure-servers:
    name: Configure Servers with Ansible
    needs: [check-changes, deploy-infrastructure]
    if: ${{ always() && needs.check-changes.outputs.run_ansible == 'true' && (needs.deploy-infrastructure.result == 'success' || needs.deploy-infrastructure.result == 'skipped') }}
    runs-on: ubuntu-latest
    env:
      BASTION_IP: ${{ needs.deploy-infrastructure.outputs.BASTION_IP }}
      APP_IP: ${{ needs.deploy-infrastructure.outputs.APP_IP }}
      MONGODB_CONNECTION_STRING: ${{ needs.deploy-infrastructure.outputs.MONGODB_CONNECTION_STRING }}
      STORAGE_ACCOUNT: ${{ needs.deploy-infrastructure.outputs.STORAGE_ACCOUNT }}
      BLOB_ENDPOINT: ${{ needs.deploy-infrastructure.outputs.BLOB_ENDPOINT }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up SSH keys
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/id_clofresvagcupg02
          chmod 600 ~/.ssh/id_clofresvagcupg02

          # Disable strict host key checking
          cat > ~/.ssh/config << EOF
          Host *
            StrictHostKeyChecking no
            UserKnownHostsFile=/dev/null
          EOF
          chmod 600 ~/.ssh/config

      - name: Check environment variables
        run: |
          echo "Bastion IP: ${{ env.BASTION_IP }}"
          echo "App IP: ${{ env.APP_IP }}"

          # Fail early if variables are missing
          if [ -z "${{ env.BASTION_IP }}" ] || [ -z "${{ env.APP_IP }}" ]; then
            # If infrastructure was skipped, use the hardcoded values
            echo "Using hardcoded values from Azure infrastructure..."
            echo "BASTION_IP=137.116.232.168" >> $GITHUB_ENV
            echo "APP_IP=10.0.2.4" >> $GITHUB_ENV
          fi

      - name: Generate fresh runner token
        id: generate_token
        run: |
          echo "Getting fresh runner token..."
          TOKEN=$(curl -X POST -H "Authorization: token ${{ secrets.PAT_TOKEN }}" \
            -H "Accept: application/vnd.github+json" \
            https://api.github.com/repos/${{ env.REPO_NAME }}/actions/runners/registration-token \
            | jq -r .token)

          echo "RUNNER_TOKEN=$TOKEN" >> $GITHUB_ENV
          echo "Fresh token generated!"

      - name: Run Ansible
        run: |
          # Create ansible inventory
          echo "Creating Ansible inventory..."
          cat > ./ansible/inventories/azure_rm.yml << EOF
          all:
            hosts:
              app_server:
                ansible_host: ${{ env.APP_IP }}
                ansible_user: azureuser
                ansible_ssh_private_key_file: ~/.ssh/id_clofresvagcupg02
                ansible_ssh_common_args: '-o ProxyCommand="ssh -W %h:%p -i ~/.ssh/id_clofresvagcupg02 azureuser@${{ env.BASTION_IP }}"'
            vars:
              project_name: ${{ env.PROJECT_NAME }}
              storage_account: ${{ env.STORAGE_ACCOUNT }}
              blob_endpoint: ${{ env.BLOB_ENDPOINT }}
              github_repo: ${{ env.REPO_NAME }}
              github_runner_token: ${{ env.RUNNER_TOKEN }}
              mongodb_connection_string: ${{ env.MONGODB_CONNECTION_STRING }}
          EOF

          echo "Waiting for SSH to be available..."
          sleep 60

          # Run app-server playbook
          ansible-playbook -i ./ansible/inventories/azure_rm.yml ./ansible/playbooks/app-server.yml

  # Build and deploy the dotnet app as an artifact and upload, if files were changed.
  deploy-app:
    name: Deploy Application
    runs-on: ubuntu-latest
    needs: [check-changes, deploy-infrastructure, configure-servers]
    env:
      BASTION_IP: ${{ needs.deploy-infrastructure.outputs.BASTION_IP }}
      APP_IP: ${{ needs.deploy-infrastructure.outputs.APP_IP }}

    # Only run if webapp files were changed and infrastructure deployment was successful.
    if: ${{ always() && needs.check-changes.outputs.run_webapp == 'true' && (needs.deploy-infrastructure.result == 'success' || needs.deploy-infrastructure.result == 'skipped') &&(needs.configure-servers.result == 'success' || needs.configure-servers.result == 'skipped') }}

    steps:

      # Check out the code from the repository
      - name: Checkout code
        uses: actions/checkout@v4

      # Set up SSH keys for deployment
      - name: Set up SSH keys
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/id_clofresvagcupg02
          chmod 600 ~/.ssh/id_clofresvagcupg02

          # Disable strict host key checking
          cat > ~/.ssh/config << EOF
          Host *
          StrictHostKeyChecking no
          UserKnownHostsFile=/dev/null
          EOF
          chmod 600 ~/.ssh/config

      # Set up .NET SDK
      - name: Setup .NET
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: 9.0.x

      # Build the web application
      - name: Build Web App
        run: |
          dotnet publish ./WebbApp/MVC_TestApp.csproj -c Release -o ./publish

          # Verify published files
          echo "Listing published files:"
          ls -la ./publish/

          # Controll that the .dll file exists
          if [ -f "./publish/MVC_TestApp.dll" ]; then
            echo "MVC_TestApp.dll found!"
          else
            echo "WARNING: MVC_TestApp.dll NOT found!"
            echo "Files in directory:"
            find ./publish -name "*.dll"
          fi

      # Deploy the application to the server
      - name: Verify deployment
        run: |
          echo "Verifying deployment..."
          # Vänta 10 sekunder för att tjänsten ska stabiliseras
          sleep 10

          # Kontrollera tjänstestatus
          ssh -o ConnectTimeout=10 -o ProxyCommand="ssh -W %h:%p -i ~/.ssh/id_clofresvagcupg02 azureuser@${{ env.BASTION_IP }}" -i ~/.ssh/id_clofresvagcupg02 azureuser@${{ env.APP_IP }} "
            echo 'Service status:'
            sudo systemctl status webapp.service || true

            echo 'Running processes:'
            ps aux | grep dotnet

            echo 'Service logs:'
            sudo journalctl -u webapp.service --no-pager -n 20 || true
          "

      # Upload the artifact to the server
      - name: Upload App Artifact
        uses: actions/upload-artifact@v4
        with:
          name: webapp
          path: ./publish
          retention-days: 1

  # Deploy the artifact to the app server.
  deploy-to-server:
    name: Deploy to Server
    needs: [deploy-app, deploy-infrastructure, configure-servers]
    runs-on: ubuntu-latest
    env:
      BASTION_IP: ${{ needs.deploy-infrastructure.outputs.BASTION_IP }}
      APP_IP: ${{ needs.deploy-infrastructure.outputs.APP_IP }}
    steps:
      - name: Check environment variables
        run: |
          echo "Bastion IP: ${{ env.BASTION_IP }}"
          echo "App IP: ${{ env.APP_IP }}"

          # Fail early if variables are missing
          if [ -z "${{ env.BASTION_IP }}" ] || [ -z "${{ env.APP_IP }}" ]; then
            # If infrastructure was skipped, use the hardcoded values
            echo "Using hardcoded values from Azure infrastructure..."
            echo "BASTION_IP=137.116.232.168" >> $GITHUB_ENV
            echo "APP_IP=10.0.2.4" >> $GITHUB_ENV
          fi

      - name: Set up SSH keys and scan hosts
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/id_clofresvagcupg02
          chmod 600 ~/.ssh/id_clofresvagcupg02

          # Skapa en SSH-config för att ignorera hostkey verification
          cat > ~/.ssh/config << EOF
          Host *
            StrictHostKeyChecking no
            UserKnownHostsFile=/dev/null
          EOF
          chmod 600 ~/.ssh/config

          # Vänta lite innan SSH-anslutning försöks
          echo "Waiting 10 seconds before trying to connect..."
          sleep 10

          # Testa SSH-anslutning till bastion med debug info
          echo "Testing SSH connection to bastion..."
          ssh -vvv -i ~/.ssh/id_clofresvagcupg02 azureuser@${{ env.BASTION_IP }} "echo 'Bastion connection successful!'" || echo "Bastion connection failed but continuing"

      - name: Debug SSH configuration
        run: |
          echo "SSH directory contents:"
          ls -la ~/.ssh/

          echo "SSH config file:"
          cat ~/.ssh/config

          echo "Testing SSH connectivity:"
          echo "Bastion IP: ${{ env.BASTION_IP }}"
          ssh -v -i ~/.ssh/id_clofresvagcupg02 azureuser@${{ env.BASTION_IP }} "echo 'Connected to Bastion'" || echo "Failed to connect to Bastion"

      - name: Download App Artifact
        uses: actions/download-artifact@v4
        with:
          name: webapp
          path: ./webapp-files

      - name: Check if deployment is necessary
        id: check_deploy
        run: |
          if [ -z "${{ env.BASTION_IP }}" ] || [ -z "${{ env.APP_IP }}" ]; then
            echo "skip=false" >> $GITHUB_OUTPUT
          else
            # Kolla om någon viktig fil har ändrats
            echo "skip=false" >> $GITHUB_OUTPUT
          fi

      - name: Create target directory and deploy app with fallback mechanisms
        run: |
          echo "Creating webapp-files directory..."
          mkdir -p ./webapp-files

          echo "Creating known_hosts file..."
          touch ~/.ssh/known_hosts

          echo "Removing old bastion host key..."
          ssh-keygen -R ${{ env.BASTION_IP }} || true

          echo "Adding bastion host key..."
          ssh-keyscan -H ${{ env.BASTION_IP }} >> ~/.ssh/known_hosts || true

          echo "Creating target directory on remote server..."
          ssh -o ConnectTimeout=10 -o ProxyCommand="ssh -W %h:%p -i ~/.ssh/id_clofresvagcupg02 azureuser@${{ env.BASTION_IP }}" -i ~/.ssh/id_clofresvagcupg02 azureuser@${{ env.APP_IP }} "sudo mkdir -p /tmp/webapp && sudo chown azureuser:azureuser /tmp/webapp"

          echo "Copying files to remote server..."
          scp -o ConnectTimeout=10 -o ProxyCommand="ssh -W %h:%p -i ~/.ssh/id_clofresvagcupg02 azureuser@${{ env.BASTION_IP }}" -i ~/.ssh/id_clofresvagcupg02 -r ./webapp-files/* azureuser@${{ env.APP_IP }}:/tmp/webapp/

          echo "Deploying files on app server..."
          ssh -o ConnectTimeout=10 -o ProxyCommand="ssh -W %h:%p -i ~/.ssh/id_clofresvagcupg02 azureuser@${{ env.BASTION_IP }}" -i ~/.ssh/id_clofresvagcupg02 azureuser@${{ env.APP_IP }} "

            echo 'Deploying application...'
            sudo systemctl stop webapp.service || echo 'Service not running yet'

            echo 'Removing old files...'
            sudo rm -rf /var/www/app/*
            sudo mkdir -p /var/www/app

            echo 'Copy files to webapp directory...'
            sudo cp -r /tmp/webapp/* /var/www/app/
            sudo chown -R www-data:www-data /var/www/app

            echo 'Listing files in webapp directory...'
            ls -la /var/www/app/

            echo 'Restarting service...'
            sudo systemctl daemon-reload
            sudo systemctl restart webapp.service

            echo 'Service status:'
            sudo systemctl status webapp.service || true
            ps aux | grep dotnet

            echo 'Service status:'
            sudo systemctl status webapp.service || true

            echo 'Service logs:'
            sudo journalctl -u webapp.service --no-pager -n 50 || true

            echo 'Application deployed!'
          "